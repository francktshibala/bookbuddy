<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Book Buddy - Component 7: Integration Testing</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .integration-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #f8f9fa;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #6c757d;
            font-size: 1.1em;
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .test-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            border-left: 5px solid #007bff;
        }

        .test-section.success {
            border-left-color: #28a745;
            background: #d4edda;
        }

        .test-section.error {
            border-left-color: #dc3545;
            background: #f8d7da;
        }

        .test-section.warning {
            border-left-color: #ffc107;
            background: #fff3cd;
        }

        .test-title {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .test-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
            margin-left: 10px;
        }

        .status-pass {
            background: #d4edda;
            color: #155724;
        }

        .status-fail {
            background: #f8d7da;
            color: #721c24;
        }

        .status-pending {
            background: #fff3cd;
            color: #856404;
        }

        .test-details {
            margin-top: 15px;
            font-size: 0.9em;
            color: #495057;
        }

        .test-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .btn-primary {
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(45deg, #dc3545, #c82333);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(45deg, #ffc107, #e0a800);
            color: #212529;
        }

        .btn-outline {
            background: transparent;
            border: 2px solid #007bff;
            color: #007bff;
        }

        .integration-flow {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .flow-step {
            display: flex;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .flow-step.active {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }

        .flow-step.complete {
            background: #e8f5e8;
            border-left: 4px solid #4caf50;
        }

        .flow-step.error {
            background: #ffebee;
            border-left: 4px solid #f44336;
        }

        .step-number {
            width: 30px;
            height: 30px;
            background: #007bff;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            font-size: 0.9em;
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .step-description {
            color: #6c757d;
            font-size: 0.9em;
        }

        .step-status {
            margin-left: 15px;
            font-size: 1.2em;
        }

        .console-output {
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.5s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .final-checklist {
            background: #e8f5e8;
            border: 2px solid #28a745;
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
        }

        .checklist-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 6px;
            transition: background 0.3s ease;
        }

        .checklist-item:hover {
            background: rgba(40, 167, 69, 0.1);
        }

        .checklist-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #28a745;
            border-radius: 4px;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #28a745;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .integration-container {
                margin: 10px;
                padding: 20px;
            }

            .test-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .stats-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="integration-container">
        <div class="header">
            <h1>üß™ Component 7: Week 1 Integration & Testing</h1>
            <p>Comprehensive testing and validation of all Week 1 components working together</p>
            <div class="progress-bar">
                <div class="progress-fill" id="overall-progress"></div>
            </div>
        </div>

        <!-- Integration Flow -->
        <div class="integration-flow">
            <h2 style="margin-bottom: 20px; color: #2c3e50;">üîÑ Integration Testing Flow</h2>
            <div id="integration-steps">
                <div class="flow-step" id="step-1">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <div class="step-title">Storage System Verification</div>
                        <div class="step-description">Test StorageManager with various data types and error conditions</div>
                    </div>
                    <div class="step-status">‚è≥</div>
                </div>

                <div class="flow-step" id="step-2">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <div class="step-title">Book Model Integration</div>
                        <div class="step-description">Validate Book class with real data and edge cases</div>
                    </div>
                    <div class="step-status">‚è≥</div>
                </div>

                <div class="flow-step" id="step-3">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <div class="step-title">File Upload Processing</div>
                        <div class="step-description">Test file upload with various file types and sizes</div>
                    </div>
                    <div class="step-status">‚è≥</div>
                </div>

                <div class="flow-step" id="step-4">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <div class="step-title">Library Management</div>
                        <div class="step-description">Test book addition, removal, and library statistics</div>
                    </div>
                    <div class="step-status">‚è≥</div>
                </div>

                <div class="flow-step" id="step-5">
                    <div class="step-number">5</div>
                    <div class="step-content">
                        <div class="step-title">Reading Interface</div>
                        <div class="step-description">Validate reading progress, position tracking, and UI</div>
                    </div>
                    <div class="step-status">‚è≥</div>
                </div>

                <div class="flow-step" id="step-6">
                    <div class="step-number">6</div>
                    <div class="step-content">
                        <div class="step-title">UI Framework Integration</div>
                        <div class="step-description">Test navigation, modals, responsive design, and data flow</div>
                    </div>
                    <div class="step-status">‚è≥</div>
                </div>

                <div class="flow-step" id="step-7">
                    <div class="step-number">7</div>
                    <div class="step-content">
                        <div class="step-title">End-to-End User Journey</div>
                        <div class="step-description">Complete workflow: Upload ‚Üí Store ‚Üí Display ‚Üí Read</div>
                    </div>
                    <div class="step-status">‚è≥</div>
                </div>
            </div>
        </div>

        <!-- Test Sections Grid -->
        <div class="test-grid">
            <div class="test-section" id="storage-test">
                <h3 class="test-title">
                    üíæ StorageManager Tests
                    <span class="test-status status-pending" id="storage-status">PENDING</span>
                </h3>
                <div class="test-details" id="storage-details">
                    Testing localStorage functionality, error handling, and data persistence...
                </div>
                <div class="test-actions">
                    <button class="btn btn-primary" onclick="runStorageTests()">üß™ Run Tests</button>
                    <button class="btn btn-outline" onclick="viewStorageData()">üìä View Data</button>
                </div>
            </div>

            <div class="test-section" id="book-test">
                <h3 class="test-title">
                    üìñ Book Model Tests
                    <span class="test-status status-pending" id="book-status">PENDING</span>
                </h3>
                <div class="test-details" id="book-details">
                    Testing Book class instantiation, progress tracking, and data serialization...
                </div>
                <div class="test-actions">
                    <button class="btn btn-primary" onclick="runBookTests()">üß™ Run Tests</button>
                    <button class="btn btn-outline" onclick="createSampleBook()">üìö Sample Book</button>
                </div>
            </div>

            <div class="test-section" id="upload-test">
                <h3 class="test-title">
                    üì§ File Upload Tests
                    <span class="test-status status-pending" id="upload-status">PENDING</span>
                </h3>
                <div class="test-details" id="upload-details">
                    Testing file validation, processing, and content extraction...
                </div>
                <div class="test-actions">
                    <button class="btn btn-primary" onclick="runUploadTests()">üß™ Run Tests</button>
                    <button class="btn btn-success" onclick="simulateFileUpload()">üìÅ Simulate Upload</button>
                </div>
            </div>

            <div class="test-section" id="library-test">
                <h3 class="test-title">
                    üìö Library Manager Tests
                    <span class="test-status status-pending" id="library-status">PENDING</span>
                </h3>
                <div class="test-details" id="library-details">
                    Testing book management, statistics calculation, and data persistence...
                </div>
                <div class="test-actions">
                    <button class="btn btn-primary" onclick="runLibraryTests()">üß™ Run Tests</button>
                    <button class="btn btn-outline" onclick="populateLibrary()">üìö Add Sample Books</button>
                </div>
            </div>

            <div class="test-section" id="reader-test">
                <h3 class="test-title">
                    üìñ Reading Interface Tests
                    <span class="test-status status-pending" id="reader-status">PENDING</span>
                </h3>
                <div class="test-details" id="reader-details">
                    Testing reading progress, position tracking, and interface responsiveness...
                </div>
                <div class="test-actions">
                    <button class="btn btn-primary" onclick="runReaderTests()">üß™ Run Tests</button>
                    <button class="btn btn-outline" onclick="simulateReading()">üìñ Simulate Reading</button>
                </div>
            </div>

            <div class="test-section" id="ui-test">
                <h3 class="test-title">
                    üé® UI Framework Tests
                    <span class="test-status status-pending" id="ui-status">PENDING</span>
                </h3>
                <div class="test-details" id="ui-details">
                    Testing navigation, modals, responsive design, and user interactions...
                </div>
                <div class="test-actions">
                    <button class="btn btn-primary" onclick="runUITests()">üß™ Run Tests</button>
                    <button class="btn btn-outline" onclick="testResponsive()">üì± Test Responsive</button>
                </div>
            </div>
        </div>

        <!-- Test Statistics -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="tests-passed">0</div>
                <div class="stat-label">Tests Passed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="tests-failed">0</div>
                <div class="stat-label">Tests Failed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="coverage-percent">0%</div>
                <div class="stat-label">Coverage</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="integration-score">0/7</div>
                <div class="stat-label">Integration Score</div>
            </div>
        </div>

        <!-- Main Action Buttons -->
        <div style="text-align: center; margin: 30px 0;">
            <button class="btn btn-success" onclick="runFullIntegrationTest()" style="font-size: 1.1em; padding: 15px 30px;">
                üöÄ Run Full Integration Test
            </button>
            <button class="btn btn-warning" onclick="runEndToEndTest()" style="font-size: 1.1em; padding: 15px 30px;">
                üîÑ End-to-End Journey Test
            </button>
            <button class="btn btn-danger" onclick="resetAllTests()" style="padding: 15px 30px;">
                üßπ Reset All Tests
            </button>
        </div>

        <!-- Week 1 Completion Checklist -->
        <div class="final-checklist">
            <h2 style="margin-bottom: 20px; color: #2c3e50;">‚úÖ Week 1 Completion Checklist</h2>
            <div id="completion-checklist">
                <div class="checklist-item" id="checklist-1">
                    <div class="checklist-checkbox" id="check-1">‚è≥</div>
                    <div>All 6 components tested individually and working correctly</div>
                </div>
                <div class="checklist-item" id="checklist-2">
                    <div class="checklist-checkbox" id="check-2">‚è≥</div>
                    <div>Components integrate seamlessly with proper data flow</div>
                </div>
                <div class="checklist-item" id="checklist-3">
                    <div class="checklist-checkbox" id="check-3">‚è≥</div>
                    <div>Error handling works across all component boundaries</div>
                </div>
                <div class="checklist-item" id="checklist-4">
                    <div class="checklist-checkbox" id="check-4">‚è≥</div>
                    <div>End-to-end user journey completes successfully</div>
                </div>
                <div class="checklist-item" id="checklist-5">
                    <div class="checklist-checkbox" id="check-5">‚è≥</div>
                    <div>Performance is acceptable with larger datasets</div>
                </div>
                <div class="checklist-item" id="checklist-6">
                    <div class="checklist-checkbox" id="check-6">‚è≥</div>
                    <div>Mobile responsiveness confirmed across devices</div>
                </div>
                <div class="checklist-item" id="checklist-7">
                    <div class="checklist-checkbox" id="check-7">‚è≥</div>
                    <div>Ready for Week 2 modular refactoring</div>
                </div>
            </div>
        </div>

        <!-- Console Output -->
        <div class="console-output" id="console-output">
            [SYSTEM] Component 7 Integration Testing Suite Initialized
            [READY] All test suites loaded and ready to execute
            [INFO] Click "Run Full Integration Test" to begin comprehensive testing
        </div>
    </div>

    <script>
        // === COMPONENT CLASSES (Simplified for Integration Testing) ===
        
        class StorageManager {
            constructor(appPrefix = 'book-buddy') {
                this.prefix = appPrefix;
                this.isAvailable = this._testStorageAvailability();
            }

            save(key, data) {
                try {
                    if (!this.isAvailable) return this._createResult(false, 'localStorage not available');
                    const prefixedKey = this._getPrefixedKey(key);
                    const jsonData = JSON.stringify(data);
                    localStorage.setItem(prefixedKey, jsonData);
                    return this._createResult(true, 'Data saved successfully', data);
                } catch (error) {
                    return this._createResult(false, `Save failed: ${error.message}`);
                }
            }

            load(key, defaultValue = null) {
                try {
                    if (!this.isAvailable) return this._createResult(true, 'localStorage not available', defaultValue);
                    const prefixedKey = this._getPrefixedKey(key);
                    const rawData = localStorage.getItem(prefixedKey);
                    if (rawData === null) return this._createResult(true, 'Key not found', defaultValue);
                    const parsedData = JSON.parse(rawData);
                    return this._createResult(true, 'Data loaded successfully', parsedData);
                } catch (error) {
                    return this._createResult(false, `Load failed: ${error.message}`, defaultValue);
                }
            }

            clear() {
                try {
                    if (!this.isAvailable) return this._createResult(false, 'localStorage not available');
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith(this.prefix + '_')) {
                            keysToRemove.push(key);
                        }
                    }
                    keysToRemove.forEach(key => localStorage.removeItem(key));
                    return this._createResult(true, `Cleared ${keysToRemove.length} keys`);
                } catch (error) {
                    return this._createResult(false, `Failed to clear storage: ${error.message}`);
                }
            }

            _getPrefixedKey(key) { return `${this.prefix}_${key}`; }
            _createResult(success, message, data = null) { return { success, message, data }; }
            _testStorageAvailability() {
                try {
                    const testKey = '__storage_test__';
                    localStorage.setItem(testKey, 'test');
                    localStorage.removeItem(testKey);
                    return true;
                } catch (error) {
                    return false;
                }
            }
        }

        class Book {
            constructor(data) {
                this.id = data.id || this.generateId();
                this.title = data.title || 'Untitled';
                this.filename = data.filename || '';
                this.content = data.content || '';
                this.wordCount = data.wordCount || this.calculateWordCount();
                this.uploadDate = data.uploadDate || new Date().toISOString();
                this.lastRead = data.lastRead || null;
                this.currentPosition = data.currentPosition || 0;
                this.readingTime = data.readingTime || 0;
            }

            generateId() {
                return `book_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
            }

            calculateWordCount() {
                if (!this.content) return 0;
                return this.content.trim().split(/\s+/).filter(word => word.length > 0).length;
            }

            getProgress() {
                if (!this.content || this.content.length === 0) return 0;
                return Math.max(0, Math.min(1, this.currentPosition / this.content.length));
            }

            updatePosition(position) {
                this.currentPosition = Math.max(0, Math.min(this.content.length, position));
                this.lastRead = new Date().toISOString();
            }

            toJSON() {
                return {
                    id: this.id, title: this.title, filename: this.filename, content: this.content,
                    wordCount: this.wordCount, uploadDate: this.uploadDate, lastRead: this.lastRead,
                    currentPosition: this.currentPosition, readingTime: this.readingTime
                };
            }
        }

        class BookManager {
            constructor(storageManager) {
                this.storage = storageManager;
                this.books = new Map();
                this.loadBooks();
            }

            addBook(bookData) {
                try {
                    const book = new Book(bookData);
                    const saveResult = this.storage.save(`book_${book.id}`, book.toJSON());
                    if (!saveResult.success) return { success: false, message: saveResult.message };
                    this.books.set(book.id, book);
                    return { success: true, book: book };
                } catch (error) {
                    return { success: false, message: error.message };
                }
            }

            getAllBooks() {
                return Array.from(this.books.values());
            }

            getBook(bookId) {
                return this.books.get(bookId);
            }

            loadBooks() {
                try {
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('book-buddy_book_')) {
                            const bookKey = key.replace('book-buddy_', '');
                            const result = this.storage.load(bookKey);
                            if (result.success && result.data) {
                                const book = new Book(result.data);
                                this.books.set(book.id, book);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error loading books:', error);
                }
            }

            getLibraryStats() {
                const books = this.getAllBooks();
                const totalBooks = books.length;
                const totalWords = books.reduce((sum, book) => sum + book.wordCount, 0);
                const avgProgress = totalBooks > 0 
                    ? books.reduce((sum, book) => sum + book.getProgress(), 0) / totalBooks
                    : 0;
                const booksRead = books.filter(book => book.getProgress() >= 1).length;
                
                return { totalBooks, totalWords, avgProgress, booksRead };
            }
        }

        // === INTEGRATION TESTING FRAMEWORK ===
        
        class IntegrationTester {
            constructor() {
                this.testResults = {};
                this.totalTests = 0;
                this.passedTests = 0;
                this.failedTests = 0;
                this.currentStep = 0;
                this.storage = new StorageManager('book-buddy-test');
                this.bookManager = new BookManager(this.storage);
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const prefix = type === 'success' ? '[PASS]' : type === 'error' ? '[FAIL]' : type === 'warning' ? '[WARN]' : '[INFO]';
                const output = `${timestamp} ${prefix} ${message}\n`;
                
                const console = document.getElementById('console-output');
                console.textContent += output;
                console.scrollTop = console.scrollHeight;
            }

            updateStep(stepNumber, status) {
                const step = document.getElementById(`step-${stepNumber}`);
                const statusElement = step.querySelector('.step-status');
                
                step.classList.remove('active', 'complete', 'error');
                
                if (status === 'active') {
                    step.classList.add('active');
                    statusElement.textContent = 'üîÑ';
                } else if (status === 'complete') {
                    step.classList.add('complete');
                    statusElement.textContent = '‚úÖ';
                } else if (status === 'error') {
                    step.classList.add('error');
                    statusElement.textContent = '‚ùå';
                }
            }

            updateTestSection(sectionId, status, details) {
                const section = document.getElementById(`${sectionId}-test`);
                const statusSpan = document.getElementById(`${sectionId}-status`);
                const detailsDiv = document.getElementById(`${sectionId}-details`);
                
                section.classList.remove('success', 'error', 'warning');
                statusSpan.classList.remove('status-pass', 'status-fail', 'status-pending');
                
                if (status === 'pass') {
                    section.classList.add('success');
                    statusSpan.classList.add('status-pass');
                    statusSpan.textContent = 'PASS';
                } else if (status === 'fail') {
                    section.classList.add('error');
                    statusSpan.classList.add('status-fail');
                    statusSpan.textContent = 'FAIL';
                } else {
                    section.classList.add('warning');
                    statusSpan.classList.add('status-pending');
                    statusSpan.textContent = 'PENDING';
                }
                
                detailsDiv.textContent = details;
            }

            updateStats() {
                document.getElementById('tests-passed').textContent = this.passedTests;
                document.getElementById('tests-failed').textContent = this.failedTests;
                document.getElementById('coverage-percent').textContent = 
                    Math.round((this.passedTests / Math.max(this.totalTests, 1)) * 100) + '%';
                document.getElementById('integration-score').textContent = `${this.currentStep}/7`;
                
                const progress = (this.currentStep / 7) * 100;
                document.getElementById('overall-progress').style.width = progress + '%';
            }

            updateChecklist(itemNumber, status) {
                const checkbox = document.getElementById(`check-${itemNumber}`);
                if (status === 'complete') {
                    checkbox.textContent = '‚úÖ';
                    checkbox.style.background = '#d4edda';
                } else if (status === 'error') {
                    checkbox.textContent = '‚ùå';
                    checkbox.style.background = '#f8d7da';
                } else {
                    checkbox.textContent = '‚è≥';
                }
            }

            async runTest(testName, testFunction) {
                this.totalTests++;
                try {
                    this.log(`Running ${testName}...`, 'info');
                    const result = await testFunction();
                    if (result.success) {
                        this.passedTests++;
                        this.log(`${testName} - PASSED: ${result.message}`, 'success');
                        return true;
                    } else {
                        this.failedTests++;
                        this.log(`${testName} - FAILED: ${result.message}`, 'error');
                        return false;
                    }
                } catch (error) {
                    this.failedTests++;
                    this.log(`${testName} - ERROR: ${error.message}`, 'error');
                    return false;
                }
            }

            // === INDIVIDUAL COMPONENT TESTS ===

            async testStorageManager() {
                this.updateStep(1, 'active');
                this.log('Starting StorageManager integration tests...', 'info');

                const tests = [
                    () => this.testStorageSaveLoad(),
                    () => this.testStorageErrorHandling(),
                    () => this.testStorageComplexData(),
                    () => this.testStorageQuota()
                ];

                let allPassed = true;
                for (const test of tests) {
                    const passed = await this.runTest('StorageManager', test);
                    if (!passed) allPassed = false;
                }

                this.updateStep(1, allPassed ? 'complete' : 'error');
                this.updateTestSection('storage', allPassed ? 'pass' : 'fail', 
                    allPassed ? 'All storage tests passed successfully' : 'Some storage tests failed');
                
                if (allPassed) this.currentStep = Math.max(this.currentStep, 1);
                return allPassed;
            }

            testStorageSaveLoad() {
                const testData = { test: 'integration', timestamp: Date.now() };
                const saveResult = this.storage.save('integration_test', testData);
                if (!saveResult.success) return { success: false, message: 'Save failed' };
                
                const loadResult = this.storage.load('integration_test');
                if (!loadResult.success || loadResult.data.test !== 'integration') {
                    return { success: false, message: 'Load failed or data corrupted' };
                }
                
                return { success: true, message: 'Save/Load working correctly' };
            }

            testStorageErrorHandling() {
                // Test loading non-existent key
                const result = this.storage.load('non_existent_key', 'default');
                if (!result.success || result.data !== 'default') {
                    return { success: false, message: 'Default value handling failed' };
                }
                
                return { success: true, message: 'Error handling working correctly' };
            }

            testStorageComplexData() {
                const complexData = {
                    books: [
                        { id: 1, title: 'Test Book 1', chapters: ['Ch1', 'Ch2'] },
                        { id: 2, title: 'Test Book 2', chapters: ['Ch1', 'Ch2', 'Ch3'] }
                    ],
                    settings: { theme: 'dark', fontSize: 16 },
                    metadata: { version: '1.0', lastUpdate: new Date().toISOString() }
                };
                
                const saveResult = this.storage.save('complex_data', complexData);
                if (!saveResult.success) return { success: false, message: 'Complex data save failed' };
                
                const loadResult = this.storage.load('complex_data');
                if (!loadResult.success || loadResult.data.books.length !== 2) {
                    return { success: false, message: 'Complex data load failed' };
                }
                
                return { success: true, message: 'Complex data handling working correctly' };
            }

            testStorageQuota() {
                // Test storage availability
                if (!this.storage.isAvailable) {
                    return { success: false, message: 'Storage not available' };
                }
                
                return { success: true, message: 'Storage quota and availability checks working' };
            }

            async testBookModel() {
                this.updateStep(2, 'active');
                this.log('Starting Book Model integration tests...', 'info');

                const tests = [
                    () => this.testBookCreation(),
                    () => this.testBookProgress(),
                    () => this.testBookSerialization(),
                    () => this.testBookEdgeCases()
                ];

                let allPassed = true;
                for (const test of tests) {
                    const passed = await this.runTest('Book Model', test);
                    if (!passed) allPassed = false;
                }

                this.updateStep(2, allPassed ? 'complete' : 'error');
                this.updateTestSection('book', allPassed ? 'pass' : 'fail',
                    allPassed ? 'All book model tests passed' : 'Some book model tests failed');
                
                if (allPassed) this.currentStep = Math.max(this.currentStep, 2);
                return allPassed;
            }

            testBookCreation() {
                const bookData = {
                    title: 'Integration Test Book',
                    filename: 'test.txt',
                    content: 'This is a test book content for integration testing. It has multiple sentences and paragraphs.'
                };
                
                const book = new Book(bookData);
                
                if (book.title !== bookData.title) {
                    return { success: false, message: 'Book title not set correctly' };
                }
                
                if (book.wordCount <= 0) {
                    return { success: false, message: 'Word count calculation failed' };
                }
                
                if (!book.id || !book.uploadDate) {
                    return { success: false, message: 'Book ID or upload date not generated' };
                }
                
                return { success: true, message: 'Book creation working correctly' };
            }

            testBookProgress() {
                const book = new Book({
                    title: 'Progress Test Book',
                    content: 'This is test content for progress tracking.'
                });
                
                // Test initial progress
                if (book.getProgress() !== 0) {
                    return { success: false, message: 'Initial progress should be 0' };
                }
                
                // Test progress update
                book.updatePosition(book.content.length / 2);
                const progress = book.getProgress();
                if (progress < 0.4 || progress > 0.6) {
                    return { success: false, message: 'Progress calculation incorrect' };
                }
                
                // Test completion
                book.updatePosition(book.content.length);
                if (book.getProgress() !== 1) {
                    return { success: false, message: 'Completion progress should be 1' };
                }
                
                return { success: true, message: 'Progress tracking working correctly' };
            }

            testBookSerialization() {
                const original = new Book({
                    title: 'Serialization Test',
                    content: 'Test content for serialization.'
                });
                
                const serialized = original.toJSON();
                const restored = new Book(serialized);
                
                if (restored.title !== original.title || restored.content !== original.content) {
                    return { success: false, message: 'Serialization/deserialization failed' };
                }
                
                return { success: true, message: 'Book serialization working correctly' };
            }

            testBookEdgeCases() {
                // Test empty content
                const emptyBook = new Book({ title: 'Empty Book', content: '' });
                if (emptyBook.wordCount !== 0 || emptyBook.getProgress() !== 0) {
                    return { success: false, message: 'Empty book handling failed' };
                }
                
                // Test undefined values
                const undefinedBook = new Book({});
                if (!undefinedBook.title || !undefinedBook.id) {
                    return { success: false, message: 'Default value handling failed' };
                }
                
                return { success: true, message: 'Edge cases handled correctly' };
            }

            async testFileUpload() {
                this.updateStep(3, 'active');
                this.log('Starting File Upload integration tests...', 'info');

                // Simulate file upload functionality
                const tests = [
                    () => this.testFileValidation(),
                    () => this.testFileProcessing(),
                    () => this.testFileContent(),
                    () => this.testFileErrorHandling()
                ];

                let allPassed = true;
                for (const test of tests) {
                    const passed = await this.runTest('File Upload', test);
                    if (!passed) allPassed = false;
                }

                this.updateStep(3, allPassed ? 'complete' : 'error');
                this.updateTestSection('upload', allPassed ? 'pass' : 'fail',
                    allPassed ? 'File upload simulation tests passed' : 'Some file upload tests failed');
                
                if (allPassed) this.currentStep = Math.max(this.currentStep, 3);
                return allPassed;
            }

            testFileValidation() {
                // Simulate valid file
                const validFile = { name: 'test.txt', size: 1024, type: 'text/plain' };
                if (!this.validateFile(validFile)) {
                    return { success: false, message: 'Valid file rejected' };
                }
                
                // Simulate invalid file
                const invalidFile = { name: 'test.pdf', size: 1024, type: 'application/pdf' };
                if (this.validateFile(invalidFile)) {
                    return { success: false, message: 'Invalid file accepted' };
                }
                
                return { success: true, message: 'File validation working correctly' };
            }

            validateFile(file) {
                const allowedTypes = ['text/plain'];
                const maxSize = 2 * 1024 * 1024; // 2MB
                return allowedTypes.includes(file.type) && file.size <= maxSize;
            }

            testFileProcessing() {
                const sampleContent = "Chapter 1\n\nThis is the first chapter of our test book.\n\nChapter 2\n\nThis is the second chapter.";
                const processed = this.processFileContent(sampleContent, 'sample.txt');
                
                if (!processed.title || !processed.content || processed.wordCount <= 0) {
                    return { success: false, message: 'File processing failed' };
                }
                
                return { success: true, message: 'File processing working correctly' };
            }

            processFileContent(content, filename) {
                const title = filename.replace(/\.[^/.]+$/, "") || 'Untitled';
                const wordCount = content.trim().split(/\s+/).filter(word => word.length > 0).length;
                
                return {
                    title: title,
                    filename: filename,
                    content: content,
                    wordCount: wordCount
                };
            }

            testFileContent() {
                const testContent = "The Great Gatsby\n\nIn my younger and more vulnerable years...";
                const book = new Book({
                    title: 'The Great Gatsby',
                    content: testContent,
                    filename: 'gatsby.txt'
                });
                
                if (book.wordCount <= 0 || !book.content.includes('vulnerable')) {
                    return { success: false, message: 'Content extraction failed' };
                }
                
                return { success: true, message: 'File content extraction working correctly' };
            }

            testFileErrorHandling() {
                // Test empty content
                try {
                    const emptyBook = new Book({ title: 'Empty', content: '', filename: 'empty.txt' });
                    if (emptyBook.wordCount !== 0) {
                        return { success: false, message: 'Empty file handling failed' };
                    }
                } catch (error) {
                    return { success: false, message: 'Empty file caused error: ' + error.message };
                }
                
                return { success: true, message: 'File error handling working correctly' };
            }

            async testLibraryManager() {
                this.updateStep(4, 'active');
                this.log('Starting Library Manager integration tests...', 'info');

                const tests = [
                    () => this.testBookAddition(),
                    () => this.testBookRetrieval(),
                    () => this.testLibraryStats(),
                    () => this.testBookPersistence()
                ];

                let allPassed = true;
                for (const test of tests) {
                    const passed = await this.runTest('Library Manager', test);
                    if (!passed) allPassed = false;
                }

                this.updateStep(4, allPassed ? 'complete' : 'error');
                this.updateTestSection('library', allPassed ? 'pass' : 'fail',
                    allPassed ? 'Library management tests passed' : 'Some library tests failed');
                
                if (allPassed) this.currentStep = Math.max(this.currentStep, 4);
                return allPassed;
            }

            testBookAddition() {
                const bookData = {
                    title: 'Library Test Book',
                    content: 'This is a test book for library management testing.',
                    filename: 'library-test.txt'
                };
                
                const result = this.bookManager.addBook(bookData);
                if (!result.success) {
                    return { success: false, message: 'Book addition failed: ' + result.message };
                }
                
                if (!result.book || !result.book.id) {
                    return { success: false, message: 'Book not properly created' };
                }
                
                return { success: true, message: 'Book addition working correctly' };
            }

            testBookRetrieval() {
                const books = this.bookManager.getAllBooks();
                if (books.length === 0) {
                    return { success: false, message: 'No books found in library' };
                }
                
                const firstBook = books[0];
                const retrievedBook = this.bookManager.getBook(firstBook.id);
                if (!retrievedBook || retrievedBook.id !== firstBook.id) {
                    return { success: false, message: 'Book retrieval failed' };
                }
                
                return { success: true, message: 'Book retrieval working correctly' };
            }

            testLibraryStats() {
                const stats = this.bookManager.getLibraryStats();
                if (typeof stats.totalBooks !== 'number' || typeof stats.totalWords !== 'number') {
                    return { success: false, message: 'Library stats calculation failed' };
                }
                
                if (stats.totalBooks < 0 || stats.totalWords < 0) {
                    return { success: false, message: 'Invalid library stats values' };
                }
                
                return { success: true, message: 'Library statistics working correctly' };
            }

            testBookPersistence() {
                // Test that books persist after reload
                const originalCount = this.bookManager.getAllBooks().length;
                
                // Create new manager instance to simulate reload
                const newManager = new BookManager(this.storage);
                const reloadedCount = newManager.getAllBooks().length;
                
                if (reloadedCount !== originalCount) {
                    return { success: false, message: 'Book persistence failed after reload' };
                }
                
                return { success: true, message: 'Book persistence working correctly' };
            }

            async testReadingInterface() {
                this.updateStep(5, 'active');
                this.log('Starting Reading Interface integration tests...', 'info');

                const tests = [
                    () => this.testReadingProgress(),
                    () => this.testPositionTracking(),
                    () => this.testReadingSession(),
                    () => this.testReadingPersistence()
                ];

                let allPassed = true;
                for (const test of tests) {
                    const passed = await this.runTest('Reading Interface', test);
                    if (!passed) allPassed = false;
                }

                this.updateStep(5, allPassed ? 'complete' : 'error');
                this.updateTestSection('reader', allPassed ? 'pass' : 'fail',
                    allPassed ? 'Reading interface tests passed' : 'Some reading interface tests failed');
                
                if (allPassed) this.currentStep = Math.max(this.currentStep, 5);
                return allPassed;
            }

            testReadingProgress() {
                const book = new Book({
                    title: 'Reading Progress Test',
                    content: 'This is a test book with exactly fifty characters.' // 50 chars
                });
                
                // Test initial state
                if (book.getProgress() !== 0) {
                    return { success: false, message: 'Initial reading progress should be 0' };
                }
                
                // Test mid-progress
                book.updatePosition(25);
                const midProgress = book.getProgress();
                if (Math.abs(midProgress - 0.5) > 0.1) {
                    return { success: false, message: 'Mid-progress calculation incorrect' };
                }
                
                return { success: true, message: 'Reading progress tracking working correctly' };
            }

            testPositionTracking() {
                const book = new Book({
                    title: 'Position Test',
                    content: 'Test content for position tracking functionality.'
                });
                
                const oldLastRead = book.lastRead;
                book.updatePosition(10);
                
                if (book.currentPosition !== 10) {
                    return { success: false, message: 'Position not updated correctly' };
                }
                
                if (book.lastRead === oldLastRead) {
                    return { success: false, message: 'Last read time not updated' };
                }
                
                return { success: true, message: 'Position tracking working correctly' };
            }

            testReadingSession() {
                const book = new Book({
                    title: 'Session Test',
                    content: 'Content for reading session simulation test.'
                });
                
                // Simulate reading session
                const startTime = Date.now();
                book.updatePosition(15);
                const sessionData = {
                    startTime: startTime,
                    endTime: Date.now(),
                    startPosition: 0,
                    endPosition: book.currentPosition
                };
                
                if (sessionData.endPosition <= sessionData.startPosition) {
                    return { success: false, message: 'Reading session progress tracking failed' };
                }
                
                return { success: true, message: 'Reading session tracking working correctly' };
            }

            testReadingPersistence() {
                // Create book and update position
                const book = new Book({
                    title: 'Persistence Test',
                    content: 'Content for testing reading position persistence.'
                });
                
                book.updatePosition(20);
                const originalPosition = book.currentPosition;
                
                // Save and reload
                const saveResult = this.storage.save('persistence_test_book', book.toJSON());
                if (!saveResult.success) {
                    return { success: false, message: 'Failed to save book for persistence test' };
                }
                
                const loadResult = this.storage.load('persistence_test_book');
                if (!loadResult.success) {
                    return { success: false, message: 'Failed to load book for persistence test' };
                }
                
                const reloadedBook = new Book(loadResult.data);
                if (reloadedBook.currentPosition !== originalPosition) {
                    return { success: false, message: 'Reading position not persisted correctly' };
                }
                
                return { success: true, message: 'Reading persistence working correctly' };
            }

            async testUIFramework() {
                this.updateStep(6, 'active');
                this.log('Starting UI Framework integration tests...', 'info');

                const tests = [
                    () => this.testNavigationSystem(),
                    () => this.testDataFlow(),
                    () => this.testResponsiveDesign(),
                    () => this.testErrorStates()
                ];

                let allPassed = true;
                for (const test of tests) {
                    const passed = await this.runTest('UI Framework', test);
                    if (!passed) allPassed = false;
                }

                this.updateStep(6, allPassed ? 'complete' : 'error');
                this.updateTestSection('ui', allPassed ? 'pass' : 'fail',
                    allPassed ? 'UI framework integration tests passed' : 'Some UI framework tests failed');
                
                if (allPassed) this.currentStep = Math.max(this.currentStep, 6);
                return allPassed;
            }

            testNavigationSystem() {
                // Test that navigation elements exist and are functional
                const navItems = document.querySelectorAll('.nav-item');
                if (navItems.length === 0) {
                    return { success: false, message: 'No navigation items found' };
                }
                
                // Test view switching capability
                const views = document.querySelectorAll('.view');
                if (views.length === 0) {
                    return { success: false, message: 'No views found for navigation' };
                }
                
                return { success: true, message: 'Navigation system structure valid' };
            }

            testDataFlow() {
                // Test data flow between components
                const stats = this.bookManager.getLibraryStats();
                
                // Verify stats object structure
                if (typeof stats !== 'object' || stats === null) {
                    return { success: false, message: 'Library stats not properly formatted' };
                }
                
                const requiredProps = ['totalBooks', 'totalWords', 'avgProgress', 'booksRead'];
                for (const prop of requiredProps) {
                    if (!(prop in stats)) {
                        return { success: false, message: `Missing property in stats: ${prop}` };
                    }
                }
                
                return { success: true, message: 'Data flow between components working correctly' };
            }

            testResponsiveDesign() {
                // Test responsive elements exist
                const mobileElements = document.querySelectorAll('.mobile-only');
                const responsiveElements = document.querySelectorAll('.nav-toggle');
                
                if (responsiveElements.length === 0) {
                    return { success: false, message: 'No responsive navigation elements found' };
                }
                
                // Test CSS classes for responsive design
                const mainNav = document.querySelector('.main-nav');
                if (!mainNav) {
                    return { success: false, message: 'Main navigation element not found' };
                }
                
                return { success: true, message: 'Responsive design elements present' };
            }

            testErrorStates() {
                // Test error handling in UI context
                try {
                    // Simulate an error condition
                    const invalidBookData = null;
                    const result = this.bookManager.addBook(invalidBookData);
                    
                    if (result.success) {
                        return { success: false, message: 'Error state not handled - invalid data accepted' };
                    }
                    
                    return { success: true, message: 'Error states handled correctly' };
                } catch (error) {
                    return { success: true, message: 'Error handling working (caught exception)' };
                }
            }

            async testEndToEndJourney() {
                this.updateStep(7, 'active');
                this.log('Starting End-to-End User Journey test...', 'info');

                const journeySteps = [
                    () => this.journeyStep1_Upload(),
                    () => this.journeyStep2_Store(),
                    () => this.journeyStep3_Display(),
                    () => this.journeyStep4_Read(),
                    () => this.journeyStep5_Progress(),
                    () => this.journeyStep6_Persist()
                ];

                let allPassed = true;
                for (let i = 0; i < journeySteps.length; i++) {
                    const stepName = `E2E Step ${i + 1}`;
                    const passed = await this.runTest(stepName, journeySteps[i]);
                    if (!passed) {
                        allPassed = false;
                        break; // Stop on first failure in E2E test
                    }
                }

                this.updateStep(7, allPassed ? 'complete' : 'error');
                
                if (allPassed) {
                    this.currentStep = Math.max(this.currentStep, 7);
                    this.log('üéâ End-to-End journey completed successfully!', 'success');
                } else {
                    this.log('‚ùå End-to-End journey failed', 'error');
                }
                
                return allPassed;
            }

            journeyStep1_Upload() {
                // Simulate file upload
                const fileContent = "Pride and Prejudice\n\nIt is a truth universally acknowledged, that a single man in possession of a good fortune, must be in want of a wife.";
                const processedFile = this.processFileContent(fileContent, "pride-and-prejudice.txt");
                
                if (!processedFile.title || !processedFile.content) {
                    return { success: false, message: 'File upload simulation failed' };
                }
                
                this.e2eBook = processedFile;
                return { success: true, message: 'File upload step completed' };
            }

            journeyStep2_Store() {
                // Store the book
                const result = this.bookManager.addBook(this.e2eBook);
                if (!result.success) {
                    return { success: false, message: 'Book storage failed: ' + result.message };
                }
                
                this.e2eBookId = result.book.id;
                return { success: true, message: 'Book storage step completed' };
            }

            journeyStep3_Display() {
                // Retrieve and display book
                const book = this.bookManager.getBook(this.e2eBookId);
                if (!book) {
                    return { success: false, message: 'Book retrieval for display failed' };
                }
                
                if (book.title !== this.e2eBook.title) {
                    return { success: false, message: 'Book data integrity check failed' };
                }
                
                return { success: true, message: 'Book display step completed' };
            }

            journeyStep4_Read() {
                // Simulate reading
                const book = this.bookManager.getBook(this.e2eBookId);
                if (!book) {
                    return { success: false, message: 'Book not found for reading' };
                }
                
                // Start reading from beginning
                const initialProgress = book.getProgress();
                if (initialProgress !== 0) {
                    return { success: false, message: 'Initial reading progress not zero' };
                }
                
                return { success: true, message: 'Reading initiation step completed' };
            }

            journeyStep5_Progress() {
                // Update reading progress
                const book = this.bookManager.getBook(this.e2eBookId);
                const halfwayPoint = Math.floor(book.content.length / 2);
                
                book.updatePosition(halfwayPoint);
                const progress = book.getProgress();
                
                if (progress < 0.4 || progress > 0.6) {
                    return { success: false, message: 'Progress tracking failed' };
                }
                
                return { success: true, message: 'Progress tracking step completed' };
            }

            journeyStep6_Persist() {
                // Save progress and verify persistence
                const book = this.bookManager.getBook(this.e2eBookId);
                const currentPosition = book.currentPosition;
                
                const saveResult = this.storage.save(`book_${book.id}`, book.toJSON());
                if (!saveResult.success) {
                    return { success: false, message: 'Progress persistence failed' };
                }
                
                // Verify by loading
                const loadResult = this.storage.load(`book_${book.id}`);
                if (!loadResult.success || loadResult.data.currentPosition !== currentPosition) {
                    return { success: false, message: 'Progress persistence verification failed' };
                }
                
                return { success: true, message: 'Progress persistence step completed' };
            }

            async runFullIntegrationTest() {
                this.log('üöÄ Starting Full Integration Test Suite...', 'info');
                this.resetStats();
                
                const testSuites = [
                    () => this.testStorageManager(),
                    () => this.testBookModel(),
                    () => this.testFileUpload(),
                    () => this.testLibraryManager(),
                    () => this.testReadingInterface(),
                    () => this.testUIFramework(),
                    () => this.testEndToEndJourney()
                ];
                
                let overallSuccess = true;
                
                for (let i = 0; i < testSuites.length; i++) {
                    const success = await testSuites[i]();
                    if (!success) {
                        overallSuccess = false;
                    }
                    
                    this.updateStats();
                    this.updateChecklist(i + 1, success ? 'complete' : 'error');
                    
                    // Add delay between test suites for better UX
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                this.log(`üèÅ Integration testing completed. Overall result: ${overallSuccess ? 'SUCCESS' : 'FAILURE'}`, 
                    overallSuccess ? 'success' : 'error');
                
                if (overallSuccess) {
                    this.log('‚úÖ Week 1 components are ready for Week 2 modular refactoring!', 'success');
                } else {
                    this.log('‚ùå Some components need attention before proceeding to Week 2', 'error');
                }
                
                return overallSuccess;
            }

            resetStats() {
                this.testResults = {};
                this.totalTests = 0;
                this.passedTests = 0;
                this.failedTests = 0;
                this.currentStep = 0;
                this.updateStats();
                
                // Reset all steps
                for (let i = 1; i <= 7; i++) {
                    this.updateStep(i, 'pending');
                    this.updateChecklist(i, 'pending');
                }
                
                // Reset test sections
                const sections = ['storage', 'book', 'upload', 'library', 'reader', 'ui'];
                sections.forEach(section => {
                    this.updateTestSection(section, 'pending', 'Test pending...');
                });
            }
        }

        // === GLOBAL INSTANCES ===
        const integrationTester = new IntegrationTester();

        // === TEST RUNNER FUNCTIONS ===
        
        async function runStorageTests() {
            await integrationTester.testStorageManager();
            integrationTester.updateStats();
        }

        async function runBookTests() {
            await integrationTester.testBookModel();
            integrationTester.updateStats();
        }

        async function runUploadTests() {
            await integrationTester.testFileUpload();
            integrationTester.updateStats();
        }

        async function runLibraryTests() {
            await integrationTester.testLibraryManager();
            integrationTester.updateStats();
        }

        async function runReaderTests() {
            await integrationTester.testReadingInterface();
            integrationTester.updateStats();
        }

        async function runUITests() {
            await integrationTester.testUIFramework();
            integrationTester.updateStats();
        }

        async function runFullIntegrationTest() {
            await integrationTester.runFullIntegrationTest();
        }

        async function runEndToEndTest() {
            integrationTester.log('üîÑ Running End-to-End User Journey Test...', 'info');
            await integrationTester.testEndToEndJourney();
            integrationTester.updateStats();
        }

        function resetAllTests() {
            integrationTester.resetStats();
            integrationTester.log('üßπ All tests reset', 'info');
            
            // Clear console
            document.getElementById('console-output').textContent = '[SYSTEM] Tests reset - ready for new test run\n';
        }

        // === UTILITY FUNCTIONS ===
        
        function viewStorageData() {
            const storage = integrationTester.storage;
            const keys = [];
            
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('book-buddy')) {
                    keys.push(key);
                }
            }
            
            integrationTester.log(`üìä Storage contains ${keys.length} Book Buddy keys`, 'info');
            keys.forEach(key => {
                integrationTester.log(`  - ${key}`, 'info');
            });
        }

        function createSampleBook() {
            const sampleData = {
                title: 'Sample Integration Book',
                filename: 'sample.txt',
                content: 'This is a sample book created for integration testing. It contains multiple paragraphs and should demonstrate all the functionality of the Book class. The content is long enough to test progress tracking and word count calculations effectively.',
            };
            
            const result = integrationTester.bookManager.addBook(sampleData);
            if (result.success) {
                integrationTester.log(`üìö Sample book created: ${result.book.title} (${result.book.wordCount} words)`, 'success');
            } else {
                integrationTester.log(`‚ùå Failed to create sample book: ${result.message}`, 'error');
            }
        }

        function simulateFileUpload() {
            integrationTester.log('üìÅ Simulating file upload process...', 'info');
            
            const files = [
                {
                    name: 'alice-in-wonderland.txt',
                    content: `Alice's Adventures in Wonderland

Chapter 1: Down the Rabbit Hole

Alice was beginning to get very tired of sitting by her sister on the bank, and of having nothing to do. Once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it.`
                },
                {
                    name: 'short-story.txt',
                    content: `The Gift of the Magi

One dollar and eighty-seven cents. That was all. And sixty cents of it was in pennies. Pennies saved one and two at a time by bulldozing the grocer and the vegetable man and the butcher until one's cheek burned with the silent imputation of parsimony that such close dealing implied.`
                }
            ];
            
            files.forEach(file => {
                const processedFile = integrationTester.processFileContent(file.content, file.name);
                const result = integrationTester.bookManager.addBook(processedFile);
                
                if (result.success) {
                    integrationTester.log(`‚úÖ Uploaded: ${file.name} (${result.book.wordCount} words)`, 'success');
                } else {
                    integrationTester.log(`‚ùå Upload failed: ${file.name} - ${result.message}`, 'error');
                }
            });
            
            integrationTester.updateStats();
        }

        function populateLibrary() {
            integrationTester.log('üìö Populating library with sample books...', 'info');
            
            const sampleBooks = [
                {
                    title: 'The Great Gatsby',
                    filename: 'gatsby.txt',
                    content: `In my younger and more vulnerable years my father gave me some advice that I've carried with me ever since. "Whenever you feel like criticizing anyone," he told me, "just remember that all the people in this world haven't had the advantages that you've had." He didn't say any more, but we've always been unusually communicative in a reserved way, and I understood that he meant a great deal more than that.`
                },
                {
                    title: '1984',
                    filename: '1984.txt',
                    content: `It was a bright cold day in April, and the clocks were striking thirteen. Winston Smith, his chin nuzzled into his breast in an effort to escape the vile wind, slipped quickly through the glass doors of Victory Mansions, though not quickly enough to prevent a swirl of gritty dust from entering along with him.`
                },
                {
                    title: 'Pride and Prejudice',
                    filename: 'pride.txt',
                    content: `It is a truth universally acknowledged, that a single man in possession of a good fortune, must be in want of a wife. However little known the feelings or views of such a man may be on his first entering a neighbourhood, this truth is so well fixed in the minds of the surrounding families, that he is considered the rightful property of some one or other of their daughters.`
                }
            ];
            
            sampleBooks.forEach(bookData => {
                const result = integrationTester.bookManager.addBook(bookData);
                if (result.success) {
                    integrationTester.log(`‚úÖ Added: ${bookData.title}`, 'success');
                } else {
                    integrationTester.log(`‚ùå Failed to add: ${bookData.title}`, 'error');
                }
            });
            
            const stats = integrationTester.bookManager.getLibraryStats();
            integrationTester.log(`üìä Library now contains ${stats.totalBooks} books with ${stats.totalWords} total words`, 'info');
        }

        function simulateReading() {
            integrationTester.log('üìñ Simulating reading session...', 'info');
            
            const books = integrationTester.bookManager.getAllBooks();
            if (books.length === 0) {
                integrationTester.log('‚ùå No books available for reading simulation', 'error');
                return;
            }
            
            const book = books[0];
            const originalProgress = book.getProgress();
            
            // Simulate reading progress
            const readAmount = Math.min(book.content.length * 0.3, book.content.length - book.currentPosition);
            book.updatePosition(book.currentPosition + readAmount);
            
            const newProgress = book.getProgress();
            const progressIncrease = newProgress - originalProgress;
            
            integrationTester.log(`üìñ Read "${book.title}" - Progress: ${(originalProgress * 100).toFixed(1)}% ‚Üí ${(newProgress * 100).toFixed(1)}% (+${(progressIncrease * 100).toFixed(1)}%)`, 'success');
            
            // Save progress
            const saveResult = integrationTester.storage.save(`book_${book.id}`, book.toJSON());
            if (saveResult.success) {
                integrationTester.log('üíæ Reading progress saved successfully', 'success');
            } else {
                integrationTester.log('‚ùå Failed to save reading progress', 'error');
            }
        }

        function testResponsive() {
            integrationTester.log('üì± Testing responsive design...', 'info');
            
            // Test mobile breakpoint simulation
            const originalWidth = window.innerWidth;
            
            // Simulate mobile width
            integrationTester.log(`Current viewport: ${window.innerWidth}px width`, 'info');
            
            // Check for responsive elements
            const mobileElements = document.querySelectorAll('.mobile-only');
            const responsiveNavigation = document.querySelector('.main-nav');
            
            if (responsiveNavigation) {
                integrationTester.log('‚úÖ Responsive navigation structure found', 'success');
            } else {
                integrationTester.log('‚ùå Responsive navigation structure missing', 'error');
            }
            
            // Test CSS media queries
            const testElement = document.createElement('div');
            testElement.style.cssText = 'width: 100%; height: 1px; position: absolute; top: -9999px;';
            document.body.appendChild(testElement);
            
            const computedStyle = window.getComputedStyle(testElement);
            integrationTester.log(`‚úÖ CSS responsive test completed`, 'success');
            
            document.body.removeChild(testElement);
        }

        // === INITIALIZATION ===
        
        document.addEventListener('DOMContentLoaded', function() {
            integrationTester.log('üèÅ Component 7: Integration Testing Suite Ready!', 'success');
            integrationTester.log('üìã Available Tests:', 'info');
            integrationTester.log('  1. StorageManager - localStorage functionality', 'info');
            integrationTester.log('  2. Book Model - data modeling and serialization', 'info');
            integrationTester.log('  3. File Upload - file processing simulation', 'info');
            integrationTester.log('  4. Library Manager - book management and statistics', 'info');
            integrationTester.log('  5. Reading Interface - progress tracking and persistence', 'info');
            integrationTester.log('  6. UI Framework - navigation and responsive design', 'info');
            integrationTester.log('  7. End-to-End Journey - complete user workflow', 'info');
            integrationTester.log('üöÄ Click "Run Full Integration Test" to validate all components!', 'info');
        });

        // === AUTO-RUN BASIC VALIDATION ===
        
        setTimeout(() => {
            integrationTester.log('üîç Running basic component validation...', 'info');
            
            // Quick validation that all components are present
            const validationResults = {
                storage: integrationTester.storage.isAvailable,
                bookManager: integrationTester.bookManager instanceof BookManager,
                bookModel: typeof Book === 'function',
                domElements: document.querySelectorAll('.test-section').length === 6
            };
            
            const allValid = Object.values(validationResults).every(result => result === true);
            
            if (allValid) {
                integrationTester.log('‚úÖ All components present and ready for testing', 'success');
            } else {
                integrationTester.log('‚ö†Ô∏è Some components may have issues:', 'warning');
                Object.entries(validationResults).forEach(([component, valid]) => {
                    if (!valid) {
                        integrationTester.log(`  - ${component}: MISSING or INVALID`, 'error');
                    }
                });
            }
        }, 1000);
    </script>
</body>
</html>