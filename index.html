<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Book Buddy - File Upload Component</title>
    <style>
        /* Previous styles... keep all your existing styles and add these */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        /* === NEW FILE UPLOAD STYLES === */
        .upload-section {
            margin: 30px 0;
            padding: 20px;
            border: 2px dashed #ddd;
            border-radius: 10px;
            background: #f8f9fa;
            transition: all 0.3s ease;
        }

        .upload-section.drag-over {
            border-color: #007bff;
            background: #e3f2fd;
            transform: scale(1.02);
        }

        .upload-area {
            text-align: center;
            padding: 40px 20px;
            cursor: pointer;
        }

        .upload-icon {
            font-size: 3em;
            color: #6c757d;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 1.2em;
            color: #495057;
            margin-bottom: 10px;
        }

        .upload-hint {
            font-size: 0.9em;
            color: #6c757d;
        }

        .file-input {
            display: none;
        }

        .progress-container {
            display: none;
            margin: 20px 0;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }

        .uploaded-files {
            margin: 20px 0;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .file-info {
            flex-grow: 1;
        }

        .file-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .file-details {
            font-size: 0.9em;
            color: #6c757d;
        }

        .file-actions button {
            margin-left: 10px;
            padding: 8px 16px;
            font-size: 0.9em;
        }

        .test-controls {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        button {
            padding: 12px 24px;
            margin: 10px;
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.4);
        }

        button.btn-secondary {
            background: linear-gradient(45deg, #6c757d, #495057);
        }

        button.btn-danger {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }

        button.btn-success {
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        #status-message {
            text-align: center;
            font-size: 1.2em;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .console-output {
            background: #1e1e1e;
            color: #00ff00;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
            white-space: pre-wrap;
        }

        .success { color: #28a745; }
        .error { color: #dc3545; }
        .info { color: #17a2b8; }
        .warning { color: #ffc107; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìö Book Buddy - File Upload System</h1>
        </header>
        
        <main>
            <!-- File Upload Section -->
            <section class="upload-section" id="upload-section">
                <div class="upload-area" onclick="document.getElementById('file-input').click()">
                    <div class="upload-icon">üìö</div>
                    <div class="upload-text">Drop your book files here or click to browse</div>
                    <div class="upload-hint">Supports: .txt files up to 2MB</div>
                </div>
                <input type="file" id="file-input" class="file-input" multiple accept=".txt" />
                
                <div class="progress-container" id="progress-container">
                    <div>Uploading: <span id="current-file">file.txt</span></div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <div><span id="progress-text">0%</span></div>
                </div>
            </section>

            <!-- Uploaded Files Display -->
            <section class="uploaded-files" id="uploaded-files" style="display: none;">
                <h3>üìñ Your Book Library</h3>
                <div id="files-list"></div>
            </section>

            <!-- Test Controls -->
            <section class="test-controls">
                <h3>üß™ Test Controls</h3>
                <button onclick="testFileUpload()" class="btn btn-success">üìÇ Test File Upload</button>
                <button onclick="runAllTests()" class="btn btn-primary">üß™ Run Storage Tests</button>
                <button onclick="demonstrateUsage()" class="btn btn-secondary">üìñ Show Examples</button>
                <button onclick="cleanupTestData()" class="btn btn-danger">üßπ Clean Up</button>
            </section>
            
            <section class="status">
                <p id="status-message">Ready! Try uploading a .txt book file above.</p>
            </section>

            <div id="console-output" class="console-output" style="display: none;"></div>
        </main>
    </div>

    <script>
        /**
         * StorageManager - Keep your existing StorageManager class exactly as is
         */
        class StorageManager {
            constructor(appPrefix = 'book-buddy') {
                this.prefix = appPrefix;
                this.maxStorageSize = 5 * 1024 * 1024; // 5MB limit
                this.warningThreshold = 0.8; // Warn at 80% capacity
                
                this.isAvailable = this._testStorageAvailability();
                
                if (!this.isAvailable) {
                    console.warn('localStorage is not available. Data will not persist.');
                }
            }

            save(key, data) {
                try {
                    if (!this.isAvailable) {
                        return this._createResult(false, 'localStorage not available');
                    }

                    const prefixedKey = this._getPrefixedKey(key);
                    const jsonData = JSON.stringify(data);
                    
                    const sizeCheck = this._checkStorageSize(jsonData);
                    if (!sizeCheck.success) {
                        return sizeCheck;
                    }

                    localStorage.setItem(prefixedKey, jsonData);
                    this._checkStorageWarning();
                    
                    return this._createResult(true, 'Data saved successfully', data);

                } catch (error) {
                    return this._handleSaveError(error, key, data);
                }
            }

            load(key, defaultValue = null) {
                try {
                    if (!this.isAvailable) {
                        return this._createResult(true, 'localStorage not available', defaultValue);
                    }

                    const prefixedKey = this._getPrefixedKey(key);
                    const rawData = localStorage.getItem(prefixedKey);
                    
                    if (rawData === null) {
                        return this._createResult(true, 'Key not found', defaultValue);
                    }

                    const parsedData = JSON.parse(rawData);
                    return this._createResult(true, 'Data loaded successfully', parsedData);

                } catch (error) {
                    return this._handleLoadError(error, key, defaultValue);
                }
            }

            remove(key) {
                try {
                    if (!this.isAvailable) {
                        return this._createResult(false, 'localStorage not available');
                    }

                    const prefixedKey = this._getPrefixedKey(key);
                    const exists = localStorage.getItem(prefixedKey) !== null;
                    
                    localStorage.removeItem(prefixedKey);
                    
                    const message = exists ? 'Key removed successfully' : 'Key did not exist';
                    return this._createResult(true, message);

                } catch (error) {
                    console.error('StorageManager remove error:', error);
                    return this._createResult(false, `Failed to remove key: ${error.message}`);
                }
            }

            clear() {
                try {
                    if (!this.isAvailable) {
                        return this._createResult(false, 'localStorage not available');
                    }

                    const keysToRemove = [];
                    
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith(this.prefix + '_')) {
                            keysToRemove.push(key);
                        }
                    }

                    keysToRemove.forEach(key => localStorage.removeItem(key));
                    
                    return this._createResult(true, `Cleared ${keysToRemove.length} keys`);

                } catch (error) {
                    console.error('StorageManager clear error:', error);
                    return this._createResult(false, `Failed to clear storage: ${error.message}`);
                }
            }

            getStorageInfo() {
                if (!this.isAvailable) {
                    return { available: false, message: 'localStorage not available' };
                }

                try {
                    let totalSize = 0;
                    let appSize = 0;
                    let appKeys = 0;

                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        const itemSize = (key.length + value.length) * 2;
                        
                        totalSize += itemSize;
                        
                        if (key.startsWith(this.prefix + '_')) {
                            appSize += itemSize;
                            appKeys++;
                        }
                    }

                    return {
                        available: true,
                        totalSize: totalSize,
                        appSize: appSize,
                        appKeys: appKeys,
                        maxSize: this.maxStorageSize,
                        percentUsed: Math.round((totalSize / this.maxStorageSize) * 100),
                        appPercentUsed: Math.round((appSize / this.maxStorageSize) * 100)
                    };

                } catch (error) {
                    console.error('StorageManager getStorageInfo error:', error);
                    return { available: false, error: error.message };
                }
            }

            _getPrefixedKey(key) {
                return `${this.prefix}_${key}`;
            }

            _createResult(success, message, data = null) {
                return { success, message, data };
            }

            _testStorageAvailability() {
                try {
                    const testKey = '__storage_test__';
                    localStorage.setItem(testKey, 'test');
                    localStorage.removeItem(testKey);
                    return true;
                } catch (error) {
                    return false;
                }
            }

            _checkStorageSize(newData) {
                try {
                    const currentSize = JSON.stringify(localStorage).length * 2;
                    const newDataSize = newData.length * 2;
                    const projectedSize = currentSize + newDataSize;

                    if (projectedSize > this.maxStorageSize) {
                        return this._createResult(false, 'Storage quota would be exceeded');
                    }

                    return this._createResult(true, 'Storage size OK');
                } catch (error) {
                    return this._createResult(true, 'Could not verify storage size');
                }
            }

            _checkStorageWarning() {
                const info = this.getStorageInfo();
                if (info.available && info.percentUsed > (this.warningThreshold * 100)) {
                    console.warn(`Storage usage high: ${info.percentUsed}% used`);
                }
            }

            _handleSaveError(error, key, data) {
                console.error('StorageManager save error:', error);

                if (error.name === 'QuotaExceededError' || error.code === 22) {
                    return this._createResult(false, 'Storage quota exceeded. Please free up space.');
                }

                if (error.name === 'SecurityError') {
                    return this._createResult(false, 'Storage access denied. Check privacy settings.');
                }

                return this._createResult(false, `Save failed: ${error.message}`);
            }

            _handleLoadError(error, key, defaultValue) {
                console.error('StorageManager load error:', error);

                if (error instanceof SyntaxError) {
                    this.remove(key);
                    return this._createResult(true, 'Corrupted data removed, using default', defaultValue);
                }

                return this._createResult(false, `Load failed: ${error.message}`, defaultValue);
            }
        }

        /**
         * === COMPONENT 3: FileUploadHandler ===
         * Handles file uploads with drag-drop, validation, and progress tracking
         */
        class FileUploadHandler {
            constructor(storageManager) {
                this.storage = storageManager;
                this.maxFileSize = 2 * 1024 * 1024; // 2MB limit
                this.allowedTypes = ['.txt']; // Only text files for now
                this.allowedMimeTypes = ['text/plain'];
                this.uploadedFiles = new Map(); // Track uploaded files
                
                this.initializeEventListeners();
                this.loadExistingFiles();
            }

            /**
             * Initialize drag-drop and file input event listeners
             */
            initializeEventListeners() {
                const uploadSection = document.getElementById('upload-section');
                const fileInput = document.getElementById('file-input');

                // File input change event
                fileInput.addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });

                // Drag and drop events
                uploadSection.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadSection.classList.add('drag-over');
                });

                uploadSection.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    uploadSection.classList.remove('drag-over');
                });

                uploadSection.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadSection.classList.remove('drag-over');
                    this.handleFiles(e.dataTransfer.files);
                });
            }

            /**
             * Process uploaded files with validation
             */
            async handleFiles(files) {
                if (!files || files.length === 0) return;

                log(`üìÇ Processing ${files.length} file(s)...`, 'info');

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    await this.processFile(file);
                }

                this.updateFilesList();
                updateStatus(`Successfully processed ${files.length} file(s)!`);
            }

            /**
             * Process a single file with validation and storage
             */
            async processFile(file) {
                try {
                    // Show progress
                    this.showProgress(file.name);

                    // Validate file
                    const validation = this.validateFile(file);
                    if (!validation.valid) {
                        log(`‚ùå ${file.name}: ${validation.error}`, 'error');
                        this.hideProgress();
                        return;
                    }

                    // Update progress
                    this.updateProgress(25, 'Validating...');

                    // Read file content
                    const content = await this.readFileContent(file);
                    this.updateProgress(75, 'Processing...');

                    // Create book object
                    const bookData = this.createBookData(file, content);

                    // Save to storage
                    const saveResult = this.storage.save(`book_${bookData.id}`, bookData);
                    if (!saveResult.success) {
                        log(`‚ùå Failed to save ${file.name}: ${saveResult.message}`, 'error');
                        this.hideProgress();
                        return;
                    }

                    // Track uploaded file
                    this.uploadedFiles.set(bookData.id, bookData);
                    
                    this.updateProgress(100, 'Complete!');
                    log(`‚úÖ Successfully uploaded: ${file.name}`, 'success');

                    // Hide progress after a short delay
                    setTimeout(() => this.hideProgress(), 1000);

                } catch (error) {
                    log(`‚ùå Error processing ${file.name}: ${error.message}`, 'error');
                    this.hideProgress();
                }
            }

            /**
             * Validate file type and size
             */
            validateFile(file) {
                // Check file extension
                const fileName = file.name.toLowerCase();
                const hasValidExtension = this.allowedTypes.some(type => fileName.endsWith(type));
                
                if (!hasValidExtension) {
                    return {
                        valid: false,
                        error: `Invalid file type. Only ${this.allowedTypes.join(', ')} files are allowed.`
                    };
                }

                // Check MIME type
                if (!this.allowedMimeTypes.includes(file.type) && file.type !== '') {
                    return {
                        valid: false,
                        error: 'Invalid file format. Please upload a text file.'
                    };
                }

                // Check file size
                if (file.size > this.maxFileSize) {
                    const maxSizeMB = this.maxFileSize / (1024 * 1024);
                    return {
                        valid: false,
                        error: `File too large. Maximum size is ${maxSizeMB}MB.`
                    };
                }

                // Check if file is empty
                if (file.size === 0) {
                    return {
                        valid: false,
                        error: 'File is empty.'
                    };
                }

                return { valid: true };
            }

            /**
             * Read file content as text
             */
            readFileContent(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        resolve(e.target.result);
                    };
                    
                    reader.onerror = () => {
                        reject(new Error('Failed to read file'));
                    };
                    
                    reader.readAsText(file);
                });
            }

            /**
             * Create book data object from file
             */
            createBookData(file, content) {
                const id = this.generateBookId(file.name);
                const preview = content.substring(0, 200) + (content.length > 200 ? '...' : '');
                
                return {
                    id: id,
                    title: this.extractTitle(file.name),
                    filename: file.name,
                    content: content,
                    preview: preview,
                    size: file.size,
                    wordCount: this.countWords(content),
                    uploadDate: new Date().toISOString(),
                    lastModified: new Date(file.lastModified).toISOString(),
                    progress: 0, // Reading progress
                    bookmarks: [],
                    notes: []
                };
            }

            /**
             * Generate unique book ID
             */
            generateBookId(filename) {
                const timestamp = Date.now();
                const random = Math.random().toString(36).substring(2, 8);
                const name = filename.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
                return `${name}_${timestamp}_${random}`;
            }

            /**
             * Extract book title from filename
             */
            extractTitle(filename) {
                // Remove file extension and clean up
                return filename
                    .replace(/\.[^/.]+$/, '') // Remove extension
                    .replace(/[_-]/g, ' ') // Replace underscores and dashes with spaces
                    .replace(/\b\w/g, l => l.toUpperCase()); // Capitalize words
            }

            /**
             * Count words in text content
             */
            countWords(text) {
                return text.trim().split(/\s+/).filter(word => word.length > 0).length;
            }

            /**
             * Show upload progress UI
             */
            showProgress(filename) {
                const progressContainer = document.getElementById('progress-container');
                const currentFile = document.getElementById('current-file');
                
                currentFile.textContent = filename;
                progressContainer.style.display = 'block';
                this.updateProgress(0, 'Starting...');
            }

            /**
             * Update progress bar
             */
            updateProgress(percent, status) {
                const progressFill = document.getElementById('progress-fill');
                const progressText = document.getElementById('progress-text');
                
                progressFill.style.width = `${percent}%`;
                progressText.textContent = `${percent}% - ${status}`;
            }

            /**
             * Hide progress UI
             */
            hideProgress() {
                const progressContainer = document.getElementById('progress-container');
                progressContainer.style.display = 'none';
            }

            /**
             * Load existing files from storage
             */
            loadExistingFiles() {
                try {
                    // Get all storage keys
                    const keys = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('book-buddy_book_')) {
                            keys.push(key.replace('book-buddy_', ''));
                        }
                    }

                    // Load each book
                    keys.forEach(key => {
                        const result = this.storage.load(key);
                        if (result.success && result.data) {
                            this.uploadedFiles.set(result.data.id, result.data);
                        }
                    });

                    if (this.uploadedFiles.size > 0) {
                        log(`üìö Loaded ${this.uploadedFiles.size} existing book(s) from storage`, 'info');
                        this.updateFilesList();
                    }

                } catch (error) {
                    log(`‚ö†Ô∏è Error loading existing files: ${error.message}`, 'warning');
                }
            }

            /**
             * Update the files list display
             */
            updateFilesList() {
                const uploadedSection = document.getElementById('uploaded-files');
                const filesList = document.getElementById('files-list');
                
                if (this.uploadedFiles.size === 0) {
                    uploadedSection.style.display = 'none';
                    return;
                }

                uploadedSection.style.display = 'block';
                filesList.innerHTML = '';

                this.uploadedFiles.forEach((book, id) => {
                    const fileItem = this.createFileItemElement(book);
                    filesList.appendChild(fileItem);
                });
            }

            /**
             * Create file item HTML element
             */
            createFileItemElement(book) {
                const item = document.createElement('div');
                item.className = 'file-item';
                
                const sizeKB = Math.round(book.size / 1024);
                const uploadDate = new Date(book.uploadDate).toLocaleDateString();
                
                item.innerHTML = `
                    <div class="file-info">
                        <div class="file-name">üìñ ${book.title}</div>
                        <div class="file-details">
                            ${book.wordCount.toLocaleString()} words ‚Ä¢ ${sizeKB}KB ‚Ä¢ Uploaded ${uploadDate}
                        </div>
                        <div class="file-details" style="margin-top: 5px; font-style: italic;">
                            "${book.preview}"
                        </div>
                    </div>
                    <div class="file-actions">
                        <button onclick="fileUploader.viewBook('${book.id}')" class="btn btn-primary">üìñ Read</button>
                        <button onclick="fileUploader.removeBook('${book.id}')" class="btn btn-danger">üóëÔ∏è Remove</button>
                    </div>
                `;
                
                return item;
            }

            /**
             * View/read a book (placeholder for now)
             */
            viewBook(bookId) {
                const book = this.uploadedFiles.get(bookId);
                if (!book) {
                    log(`‚ùå Book not found: ${bookId}`, 'error');
                    return;
                }

                log(`üìñ Opening book: ${book.title}`, 'info');
                log(`Content preview: "${book.content.substring(0, 500)}..."`, 'info');
                updateStatus(`üìñ Reading: ${book.title} (${book.wordCount} words)`);
            }

            /**
             * Remove a book from storage and list
             */
            removeBook(bookId) {
                if (!confirm('Are you sure you want to remove this book?')) {
                    return;
                }

                const book = this.uploadedFiles.get(bookId);
                if (!book) {
                    log(`‚ùå Book not found: ${bookId}`, 'error');
                    return;
                }

                // Remove from storage
                const result = this.storage.remove(`book_${bookId}`);
                if (result.success) {
                    // Remove from local map
                    this.uploadedFiles.delete(bookId);
                    this.updateFilesList();
                    log(`üóëÔ∏è Removed book: ${book.title}`, 'success');
                    updateStatus(`Removed: ${book.title}`);
                } else {
                    log(`‚ùå Failed to remove book: ${result.message}`, 'error');
                }
            }

            /**
             * Get upload statistics
             */
            getUploadStats() {
                const totalFiles = this.uploadedFiles.size;
                let totalSize = 0;
                let totalWords = 0;

                this.uploadedFiles.forEach(book => {
                    totalSize += book.size;
                    totalWords += book.wordCount;
                });

                return {
                    totalFiles,
                    totalSize,
                    totalWords,
                    averageSize: totalFiles > 0 ? Math.round(totalSize / totalFiles) : 0,
                    averageWords: totalFiles > 0 ? Math.round(totalWords / totalFiles) : 0
                };
            }
        }

        // Initialize the app with existing storage code
        const storage = new StorageManager('book-buddy');
        const fileUploader = new FileUploadHandler(storage);
        let consoleOutput = '';

        // Keep all your existing console logging functions...
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            const output = `[${timestamp}] ${prefix} ${message}\n`;
            consoleOutput += output;
            
            const outputDiv = document.getElementById('console-output');
            outputDiv.textContent = consoleOutput;
            outputDiv.style.display = 'block';
            outputDiv.scrollTop = outputDiv.scrollHeight;
            
            console.log(message);
        }

        function updateStatus(message) {
            document.getElementById('status-message').textContent = message;
        }

        // === NEW FILE UPLOAD TEST FUNCTION ===
        function testFileUpload() {
            consoleOutput = '';
            log('üìÇ Testing File Upload Component...', 'info');
            updateStatus('Testing file upload functionality...');

            // Test file validation
            log('üîç Testing file validation...', 'info');
            
            // Create mock files for testing
            const validFile = new File(['This is a test book content with multiple words to test.'], 'test-book.txt', {
                type: 'text/plain',
                lastModified: Date.now()
            });

            const invalidFile = new File(['test'], 'test.pdf', {
                type: 'application/pdf',
                lastModified: Date.now()
            });

            // Test validation
            const validResult = fileUploader.validateFile(validFile);
            log(`Valid .txt file: ${validResult.valid ? 'PASS' : 'FAIL'} - ${validResult.error || 'OK'}`, 
                validResult.valid ? 'success' : 'error');

            const invalidResult = fileUploader.validateFile(invalidFile);
            log(`Invalid .pdf file: ${!invalidResult.valid ? 'PASS' : 'FAIL'} - ${invalidResult.error || 'Should fail'}`, 
                !invalidResult.valid ? 'success' : 'error');

            // Test utility functions
            log('üõ†Ô∏è Testing utility functions...', 'info');
            
            const testTitle = fileUploader.extractTitle('the-great-gatsby.txt');
            log(`Title extraction: ${testTitle === 'The Great Gatsby' ? 'PASS' : 'FAIL'} - Got: "${testTitle}"`, 
                testTitle === 'The Great Gatsby' ? 'success' : 'error');

            const testWords = fileUploader.countWords('Hello world this is a test');
            log(`Word counting: ${testWords === 6 ? 'PASS' : 'FAIL'} - Got: ${testWords}`, 
                testWords === 6 ? 'success' : 'error');

            // Test book ID generation
            const bookId = fileUploader.generateBookId('test-book.txt');
            log(`Book ID generation: ${bookId.includes('testbook') ? 'PASS' : 'FAIL'} - Got: ${bookId}`, 
                bookId.includes('testbook') ? 'success' : 'error');

            // Test upload stats
            const stats = fileUploader.getUploadStats();
            log(`Upload stats: Files: ${stats.totalFiles}, Total words: ${stats.totalWords}`, 'info');

            log('‚úÖ File upload component tests completed!', 'success');
            updateStatus('File upload tests completed! Try uploading a real .txt file above.');
        }

        // Keep all your existing test functions...
        function runAllTests() {
            consoleOutput = '';
            log('üß™ Starting All Tests...', 'info');
            updateStatus('Running all tests...');
            
            testBasicOperations();
            testComplexData();
            testErrorHandling();
            testStorageManagement();
            testFileUpload();
            
            log('‚úÖ All tests completed!', 'success');
            updateStatus('All tests completed! File upload component is ready.');
        }

        function testBasicOperations() {
            log('üìù Testing basic save/load operations...', 'info');
            
            let result = storage.save('test_string', 'Hello World');
            log(`Save string: ${result.success ? 'PASS' : 'FAIL'} - ${result.message}`, 
                result.success ? 'success' : 'error');
            
            result = storage.load('test_string');
            log(`Load string: ${result.success && result.data === 'Hello World' ? 'PASS' : 'FAIL'} - Got: ${result.data}`, 
                result.success && result.data === 'Hello World' ? 'success' : 'error');
            
            storage.save('test_number', 42);
            result = storage.load('test_number');
            log(`Number data: ${result.success && result.data === 42 ? 'PASS' : 'FAIL'} - Got: ${result.data}`, 
                result.success && result.data === 42 ? 'success' : 'error');
            
            result = storage.load('nonexistent', 'default');
            log(`Default value: ${result.data === 'default' ? 'PASS' : 'FAIL'} - Got: ${result.data}`, 
                result.data === 'default' ? 'success' : 'error');
        }

        function testComplexData() {
            log('üìä Testing complex data structures...', 'info');
            
            const bookData = {
                id: 'book_1',
                title: 'Test Book',
                author: 'Test Author',
                chapters: ['Chapter 1', 'Chapter 2'],
                metadata: {
                    pages: 100,
                    genre: 'Fiction'
                }
            };
            
            let result = storage.save('complex_book', bookData);
            log(`Save complex object: ${result.success ? 'PASS' : 'FAIL'} - ${result.message}`, 
                result.success ? 'success' : 'error');
            
            result = storage.load('complex_book');
            const isValid = result.success && 
                           result.data.title === 'Test Book' &&
                           result.data.chapters.length === 2 &&
                           result.data.metadata.pages === 100;
            log(`Load complex object: ${isValid ? 'PASS' : 'FAIL'}`, 
                isValid ? 'success' : 'error');
        }

        function testErrorHandling() {
            log('üö´ Testing error handling...', 'info');
            
            localStorage.setItem('book-buddy_corrupted', '{invalid json');
            const result = storage.load('corrupted', 'fallback');
            log(`Corrupted data handling: ${result.data === 'fallback' ? 'PASS' : 'FAIL'} - ${result.message}`, 
                result.data === 'fallback' ? 'success' : 'error');
        }

        function testStorageManagement() {
            log('üóÇÔ∏è Testing storage management...', 'info');
            
            const info = storage.getStorageInfo();
            log(`Storage info available: ${info.available ? 'PASS' : 'FAIL'}`, 
                info.available ? 'success' : 'error');
            
            if (info.available) {
                log(`Storage usage: ${info.appSize} bytes (${info.appPercentUsed}%)`, 'info');
            }
            
            storage.save('temp_item', 'temporary');
            let result = storage.remove('temp_item');
            log(`Remove item: ${result.success ? 'PASS' : 'FAIL'} - ${result.message}`, 
                result.success ? 'success' : 'error');
        }

        function demonstrateUsage() {
            consoleOutput = '';
            log('üìñ Book Buddy Usage Examples', 'info');
            updateStatus('Running usage examples...');
            
            const sampleBook = {
                id: 'gatsby_001',
                title: 'The Great Gatsby',
                author: 'F. Scott Fitzgerald',
                content: 'In my younger and more vulnerable years my father gave me some advice...',
                currentPage: 45,
                totalPages: 180,
                notes: ['Classic American literature', 'Symbolism of the green light'],
                lastRead: new Date().toISOString()
            };
            
            log('üíæ Saving sample book...', 'info');
            let result = storage.save('current_book', sampleBook);
            log(`Book saved: ${result.success ? 'SUCCESS' : 'FAILED'} - ${result.message}`, 
                result.success ? 'success' : 'error');
            
            log('üìñ Loading book...', 'info');
            result = storage.load('current_book');
            if (result.success) {
                const book = result.data;
                log(`Loaded: "${book.title}" by ${book.author}`, 'success');
                log(`Progress: ${Math.round((book.currentPage / book.totalPages) * 100)}% complete`, 'info');
                log(`Notes: ${book.notes.join(', ')}`, 'info');
            }

            // Demonstrate file upload capabilities
            log('üìÇ File Upload Capabilities:', 'info');
            log(`- Supported formats: ${fileUploader.allowedTypes.join(', ')}`, 'info');
            log(`- Maximum file size: ${fileUploader.maxFileSize / (1024 * 1024)}MB`, 'info');
            log(`- Current library: ${fileUploader.uploadedFiles.size} book(s)`, 'info');
            
            const stats = fileUploader.getUploadStats();
            if (stats.totalFiles > 0) {
                log(`- Total words in library: ${stats.totalWords.toLocaleString()}`, 'info');
                log(`- Average book size: ${Math.round(stats.averageSize / 1024)}KB`, 'info');
            }
            
            updateStatus('Usage examples completed! Try uploading your own .txt files above.');
        }

        function cleanupTestData() {
            log('üßπ Cleaning up test data...', 'info');
            const result = storage.clear();
            
            // Also clear the file uploader's memory
            fileUploader.uploadedFiles.clear();
            fileUploader.updateFilesList();
            
            log(`Cleanup result: ${result.success ? 'SUCCESS' : 'FAILED'} - ${result.message}`, 
                result.success ? 'success' : 'error');
            updateStatus('All test data cleaned up! Upload section reset.');
        }

        // Initialize the app
        updateStatus(`üìö Book Buddy File Upload Ready! Drop a .txt file above or click to browse.`);
        log('üöÄ Book Buddy with File Upload initialized!', 'success');
        log(`Storage available: ${storage.isAvailable}`, 'info');
        log(`File upload ready - supported types: ${fileUploader.allowedTypes.join(', ')}`, 'info');
        
        // Test initial functionality
        const initialTest = storage.save('app_initialized', { 
            timestamp: new Date().toISOString(),
            version: '1.1.0',
            components: ['StorageManager', 'FileUploadHandler']
        });
        
        if (initialTest.success) {
            log('‚úÖ Components initialized successfully!', 'success');
        } else {
            log('‚ùå Component initialization failed!', 'error');
        }

        // Make fileUploader available globally for button clicks
        window.fileUploader = fileUploader;
    </script>
</body>
</html>