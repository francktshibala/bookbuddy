<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Book Buddy - Library Manager</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        /* === LIBRARY MANAGER STYLES === */
        .library-section {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .library-stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
            min-width: 120px;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .search-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .search-input {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #007bff;
        }

        .filter-select {
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }

        .view-toggle {
            display: flex;
            background: #e9ecef;
            border-radius: 8px;
            overflow: hidden;
        }

        .view-btn {
            padding: 10px 15px;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .view-btn.active {
            background: #007bff;
            color: white;
        }

        /* === BOOK DISPLAY STYLES === */
        .books-container {
            display: grid;
            gap: 20px;
            margin-top: 20px;
        }

        .books-grid {
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        }

        .books-list {
            grid-template-columns: 1fr;
        }

        .book-card {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            position: relative;
        }

        .book-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0,0,0,0.2);
        }

        .book-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .book-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .book-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 10px 0;
            font-size: 0.9em;
            color: #6c757d;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .book-preview {
            font-style: italic;
            color: #495057;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #007bff;
            line-height: 1.5;
        }

        .book-progress {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(45deg, #28a745, #20c997);
            transition: width 0.3s ease;
        }

        .book-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .book-actions button {
            flex: 1;
            min-width: 80px;
            padding: 8px 12px;
            font-size: 0.9em;
        }

        /* === UPLOAD SECTION STYLES === */
        .upload-section {
            margin: 30px 0;
            padding: 20px;
            border: 2px dashed #ddd;
            border-radius: 10px;
            background: #f8f9fa;
            transition: all 0.3s ease;
        }

        .upload-section.drag-over {
            border-color: #007bff;
            background: #e3f2fd;
            transform: scale(1.02);
        }

        .upload-area {
            text-align: center;
            padding: 40px 20px;
            cursor: pointer;
        }

        .upload-icon {
            font-size: 3em;
            color: #6c757d;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 1.2em;
            color: #495057;
            margin-bottom: 10px;
        }

        .upload-hint {
            font-size: 0.9em;
            color: #6c757d;
        }

        .file-input {
            display: none;
        }

        .progress-container {
            display: none;
            margin: 20px 0;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }

        .test-controls {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        button {
            padding: 12px 24px;
            margin: 5px;
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.4);
        }

        button.btn-secondary {
            background: linear-gradient(45deg, #6c757d, #495057);
        }

        button.btn-danger {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }

        button.btn-success {
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        button.btn-warning {
            background: linear-gradient(45deg, #ffc107, #e0a800);
            color: #333;
        }

        #status-message {
            text-align: center;
            font-size: 1.2em;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .console-output {
            background: #1e1e1e;
            color: #00ff00;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
            white-space: pre-wrap;
        }

        .success { color: #28a745; }
        .error { color: #dc3545; }
        .info { color: #17a2b8; }
        .warning { color: #ffc107; }

        .empty-library {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .empty-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .library-header {
                flex-direction: column;
                align-items: stretch;
            }

            .search-controls {
                flex-direction: column;
            }

            .search-input {
                min-width: 100%;
            }

            .books-container {
                grid-template-columns: 1fr;
            }

            .book-actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìö Book Buddy - Smart Library</h1>
        </header>
        
        <main>
            <!-- File Upload Section -->
            <section class="upload-section" id="upload-section">
                <div class="upload-area" onclick="document.getElementById('file-input').click()">
                    <div class="upload-icon">üìö</div>
                    <div class="upload-text">Drop your book files here or click to browse</div>
                    <div class="upload-hint">Supports: .txt files up to 2MB</div>
                </div>
                <input type="file" id="file-input" class="file-input" multiple accept=".txt" />
                
                <div class="progress-container" id="progress-container">
                    <div>Uploading: <span id="current-file">file.txt</span></div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <div><span id="progress-text">0%</span></div>
                </div>
            </section>

            <!-- Library Manager Section -->
            <section class="library-section" id="library-section">
                <div class="library-header">
                    <h2>üìñ Your Library</h2>
                    <div class="library-stats" id="library-stats">
                        <div class="stat-item">
                            <div class="stat-number" id="total-books">0</div>
                            <div class="stat-label">Books</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="total-words">0</div>
                            <div class="stat-label">Words</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="avg-progress">0%</div>
                            <div class="stat-label">Progress</div>
                        </div>
                    </div>
                </div>

                <div class="search-controls">
                    <input type="text" id="search-input" class="search-input" placeholder="üîç Search books by title or content...">
                    <select id="sort-select" class="filter-select">
                        <option value="title">üìù Sort by Title</option>
                        <option value="date">üìÖ Sort by Date Added</option>
                        <option value="size">üìä Sort by Size</option>
                        <option value="progress">üìñ Sort by Progress</option>
                    </select>
                    <div class="view-toggle">
                        <button class="view-btn active" id="grid-view" onclick="bookManager.setView('grid')">üì± Grid</button>
                        <button class="view-btn" id="list-view" onclick="bookManager.setView('list')">üìã List</button>
                    </div>
                </div>

                <div class="books-container books-grid" id="books-container">
                    <div class="empty-library" id="empty-library">
                        <div class="empty-icon">üìö</div>
                        <h3>Your library is empty</h3>
                        <p>Upload some .txt files above to get started!</p>
                    </div>
                </div>
            </section>

            <!-- Test Controls -->
            <section class="test-controls">
                <h3>üß™ Test & Demo Controls</h3>
                <button onclick="testBookManager()" class="btn btn-success">üìö Test Library Manager</button>
                <button onclick="addSampleBooks()" class="btn btn-warning">üìñ Add Sample Books</button>
                <button onclick="testFileUpload()" class="btn btn-success">üìÇ Test File Upload</button>
                <button onclick="runAllTests()" class="btn btn-primary">üß™ Run All Tests</button>
                <button onclick="demonstrateUsage()" class="btn btn-secondary">üìñ Show Examples</button>
                <button onclick="cleanupTestData()" class="btn btn-danger">üßπ Clean Up</button>
            </section>
            
            <section class="status">
                <p id="status-message">üìö Book Buddy Library Manager ready! Upload files or add sample books to test.</p>
            </section>

            <div id="console-output" class="console-output" style="display: none;"></div>
        </main>
    </div>

    <script>
        // === COMPONENT 1: StorageManager ===
        class StorageManager {
            constructor(appPrefix = 'book-buddy') {
                this.prefix = appPrefix;
                this.maxStorageSize = 5 * 1024 * 1024;
                this.warningThreshold = 0.8;
                this.isAvailable = this._testStorageAvailability();
                
                if (!this.isAvailable) {
                    console.warn('localStorage is not available. Data will not persist.');
                }
            }

            save(key, data) {
                try {
                    if (!this.isAvailable) {
                        return this._createResult(false, 'localStorage not available');
                    }

                    const prefixedKey = this._getPrefixedKey(key);
                    const jsonData = JSON.stringify(data);
                    
                    const sizeCheck = this._checkStorageSize(jsonData);
                    if (!sizeCheck.success) {
                        return sizeCheck;
                    }

                    localStorage.setItem(prefixedKey, jsonData);
                    this._checkStorageWarning();
                    
                    return this._createResult(true, 'Data saved successfully', data);
                } catch (error) {
                    return this._handleSaveError(error, key, data);
                }
            }

            load(key, defaultValue = null) {
                try {
                    if (!this.isAvailable) {
                        return this._createResult(true, 'localStorage not available', defaultValue);
                    }

                    const prefixedKey = this._getPrefixedKey(key);
                    const rawData = localStorage.getItem(prefixedKey);
                    
                    if (rawData === null) {
                        return this._createResult(true, 'Key not found', defaultValue);
                    }

                    const parsedData = JSON.parse(rawData);
                    return this._createResult(true, 'Data loaded successfully', parsedData);
                } catch (error) {
                    return this._handleLoadError(error, key, defaultValue);
                }
            }

            remove(key) {
                try {
                    if (!this.isAvailable) {
                        return this._createResult(false, 'localStorage not available');
                    }

                    const prefixedKey = this._getPrefixedKey(key);
                    const exists = localStorage.getItem(prefixedKey) !== null;
                    localStorage.removeItem(prefixedKey);
                    
                    const message = exists ? 'Key removed successfully' : 'Key did not exist';
                    return this._createResult(true, message);
                } catch (error) {
                    console.error('StorageManager remove error:', error);
                    return this._createResult(false, `Failed to remove key: ${error.message}`);
                }
            }

            clear() {
                try {
                    if (!this.isAvailable) {
                        return this._createResult(false, 'localStorage not available');
                    }

                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith(this.prefix + '_')) {
                            keysToRemove.push(key);
                        }
                    }

                    keysToRemove.forEach(key => localStorage.removeItem(key));
                    return this._createResult(true, `Cleared ${keysToRemove.length} keys`);
                } catch (error) {
                    console.error('StorageManager clear error:', error);
                    return this._createResult(false, `Failed to clear storage: ${error.message}`);
                }
            }

            getStorageInfo() {
                if (!this.isAvailable) {
                    return { available: false, message: 'localStorage not available' };
                }

                try {
                    let totalSize = 0;
                    let appSize = 0;
                    let appKeys = 0;

                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        const itemSize = (key.length + value.length) * 2;
                        
                        totalSize += itemSize;
                        
                        if (key.startsWith(this.prefix + '_')) {
                            appSize += itemSize;
                            appKeys++;
                        }
                    }

                    return {
                        available: true,
                        totalSize: totalSize,
                        appSize: appSize,
                        appKeys: appKeys,
                        maxSize: this.maxStorageSize,
                        percentUsed: Math.round((totalSize / this.maxStorageSize) * 100),
                        appPercentUsed: Math.round((appSize / this.maxStorageSize) * 100)
                    };
                } catch (error) {
                    console.error('StorageManager getStorageInfo error:', error);
                    return { available: false, error: error.message };
                }
            }

            _getPrefixedKey(key) {
                return `${this.prefix}_${key}`;
            }

            _createResult(success, message, data = null) {
                return { success, message, data };
            }

            _testStorageAvailability() {
                try {
                    const testKey = '__storage_test__';
                    localStorage.setItem(testKey, 'test');
                    localStorage.removeItem(testKey);
                    return true;
                } catch (error) {
                    return false;
                }
            }

            _checkStorageSize(newData) {
                try {
                    const currentSize = JSON.stringify(localStorage).length * 2;
                    const newDataSize = newData.length * 2;
                    const projectedSize = currentSize + newDataSize;

                    if (projectedSize > this.maxStorageSize) {
                        return this._createResult(false, 'Storage quota would be exceeded');
                    }

                    return this._createResult(true, 'Storage size OK');
                } catch (error) {
                    return this._createResult(true, 'Could not verify storage size');
                }
            }

            _checkStorageWarning() {
                const info = this.getStorageInfo();
                if (info.available && info.percentUsed > (this.warningThreshold * 100)) {
                    console.warn(`Storage usage high: ${info.percentUsed}% used`);
                }
            }

            _handleSaveError(error, key, data) {
                console.error('StorageManager save error:', error);

                if (error.name === 'QuotaExceededError' || error.code === 22) {
                    return this._createResult(false, 'Storage quota exceeded. Please free up space.');
                }

                if (error.name === 'SecurityError') {
                    return this._createResult(false, 'Storage access denied. Check privacy settings.');
                }

                return this._createResult(false, `Save failed: ${error.message}`);
            }

            _handleLoadError(error, key, defaultValue) {
                console.error('StorageManager load error:', error);

                if (error instanceof SyntaxError) {
                    this.remove(key);
                    return this._createResult(true, 'Corrupted data removed, using default', defaultValue);
                }

                return this._createResult(false, `Load failed: ${error.message}`, defaultValue);
            }
        }

        // === COMPONENT 2: Book Class ===
        class Book {
            constructor(data) {
                this.id = data.id || this.generateId();
                this.title = data.title || 'Untitled';
                this.filename = data.filename || '';
                this.content = data.content || '';
                this.preview = data.preview || this.generatePreview();
                this.size = data.size || 0;
                this.wordCount = data.wordCount || this.calculateWordCount();
                this.uploadDate = data.uploadDate || new Date().toISOString();
                this.lastModified = data.lastModified || new Date().toISOString();
                this.lastRead = data.lastRead || null;
                this.progress = data.progress || 0; // 0-1 (percentage read)
                this.bookmarks = data.bookmarks || [];
                this.notes = data.notes || [];
                this.tags = data.tags || [];
                this.rating = data.rating || 0; // 0-5 stars
            }

            generateId() {
                return `book_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
            }

            generatePreview(length = 200) {
                if (!this.content) return '';
                return this.content.substring(0, length) + (this.content.length > length ? '...' : '');
            }

            calculateWordCount() {
                if (!this.content) return 0;
                return this.content.trim().split(/\s+/).filter(word => word.length > 0).length;
            }

            updateProgress(newProgress) {
                this.progress = Math.max(0, Math.min(1, newProgress));
                this.lastRead = new Date().toISOString();
            }

            addBookmark(position, note = '') {
                const bookmark = {
                    id: `bookmark_${Date.now()}`,
                    position,
                    note,
                    created: new Date().toISOString()
                };
                this.bookmarks.push(bookmark);
                return bookmark;
            }

            removeBookmark(bookmarkId) {
                this.bookmarks = this.bookmarks.filter(b => b.id !== bookmarkId);
            }

            addNote(content, position = 0) {
                const note = {
                    id: `note_${Date.now()}`,
                    content,
                    position,
                    created: new Date().toISOString()
                };
                this.notes.push(note);
                return note;
            }

            removeNote(noteId) {
                this.notes = this.notes.filter(n => n.id !== noteId);
            }

            addTag(tag) {
                if (!this.tags.includes(tag)) {
                    this.tags.push(tag);
                }
            }

            removeTag(tag) {
                this.tags = this.tags.filter(t => t !== tag);
            }

            setRating(rating) {
                this.rating = Math.max(0, Math.min(5, rating));
            }

            getReadingTime(wordsPerMinute = 250) {
                return Math.ceil(this.wordCount / wordsPerMinute);
            }

            getTimeToFinish(wordsPerMinute = 250) {
                const wordsRemaining = this.wordCount * (1 - this.progress);
                return Math.ceil(wordsRemaining / wordsPerMinute);
            }

            toJSON() {
                return {
                    id: this.id,
                    title: this.title,
                    filename: this.filename,
                    content: this.content,
                    preview: this.preview,
                    size: this.size,
                    wordCount: this.wordCount,
                    uploadDate: this.uploadDate,
                    lastModified: this.lastModified,
                    lastRead: this.lastRead,
                    progress: this.progress,
                    bookmarks: this.bookmarks,
                    notes: this.notes,
                    tags: this.tags,
                    rating: this.rating
                };
            }
        }

        // === COMPONENT 4: BookManager ===
        class BookManager {
            constructor(storageManager) {
                this.storage = storageManager;
                this.books = new Map();
                this.currentView = 'grid';
                this.sortBy = 'title';
                this.searchQuery = '';
                
                this.initializeEventListeners();
                this.loadBooks();
                this.updateDisplay();
            }

            initializeEventListeners() {
                // Search functionality
                const searchInput = document.getElementById('search-input');
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => {
                        this.searchQuery = e.target.value.toLowerCase();
                        this.updateDisplay();
                    });
                }

                // Sort functionality
                const sortSelect = document.getElementById('sort-select');
                if (sortSelect) {
                    sortSelect.addEventListener('change', (e) => {
                        this.sortBy = e.target.value;
                        this.updateDisplay();
                    });
                }
            }

            addBook(bookData) {
                try {
                    const book = new Book(bookData);
                    
                    // Save to storage
                    const saveResult = this.storage.save(`book_${book.id}`, book.toJSON());
                    if (!saveResult.success) {
                        log(`‚ùå Failed to save book: ${saveResult.message}`, 'error');
                        return { success: false, message: saveResult.message };
                    }

                    // Add to local collection
                    this.books.set(book.id, book);
                    this.updateDisplay();
                    
                    log(`‚úÖ Added book: ${book.title}`, 'success');
                    return { success: true, book: book };
                } catch (error) {
                    log(`‚ùå Error adding book: ${error.message}`, 'error');
                    return { success: false, message: error.message };
                }
            }

            removeBook(bookId) {
                try {
                    const book = this.books.get(bookId);
                    if (!book) {
                        return { success: false, message: 'Book not found' };
                    }

                    // Remove from storage
                    const removeResult = this.storage.remove(`book_${bookId}`);
                    if (!removeResult.success) {
                        return { success: false, message: removeResult.message };
                    }

                    // Remove from local collection
                    this.books.delete(bookId);
                    this.updateDisplay();
                    
                    log(`üóëÔ∏è Removed book: ${book.title}`, 'success');
                    return { success: true };
                } catch (error) {
                    log(`‚ùå Error removing book: ${error.message}`, 'error');
                    return { success: false, message: error.message };
                }
            }

            getBook(bookId) {
                return this.books.get(bookId);
            }

            getAllBooks() {
                return Array.from(this.books.values());
            }

            searchBooks(query) {
                if (!query) return this.getAllBooks();
                
                const lowerQuery = query.toLowerCase();
                return this.getAllBooks().filter(book => 
                    book.title.toLowerCase().includes(lowerQuery) ||
                    book.content.toLowerCase().includes(lowerQuery) ||
                    book.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
                );
            }

            sortBooks(books, sortBy) {
                return books.sort((a, b) => {
                    switch (sortBy) {
                        case 'title':
                            return a.title.localeCompare(b.title);
                        case 'date':
                            return new Date(b.uploadDate) - new Date(a.uploadDate);
                        case 'size':
                            return b.wordCount - a.wordCount;
                        case 'progress':
                            return b.progress - a.progress;
                        default:
                            return 0;
                    }
                });
            }

            updateBookProgress(bookId, progress) {
                const book = this.books.get(bookId);
                if (!book) return { success: false, message: 'Book not found' };

                book.updateProgress(progress);
                
                // Save updated book to storage
                const saveResult = this.storage.save(`book_${bookId}`, book.toJSON());
                if (!saveResult.success) {
                    return { success: false, message: saveResult.message };
                }

                this.updateDisplay();
                return { success: true };
            }

            setView(viewType) {
                this.currentView = viewType;
                
                // Update view toggle buttons
                document.getElementById('grid-view').classList.toggle('active', viewType === 'grid');
                document.getElementById('list-view').classList.toggle('active', viewType === 'list');
                
                // Update container class
                const container = document.getElementById('books-container');
                container.className = `books-container books-${viewType}`;
                
                this.updateDisplay();
            }

            loadBooks() {
                try {
                    // Get all book keys from storage
                    const keys = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('book-buddy_book_')) {
                            keys.push(key.replace('book-buddy_', ''));
                        }
                    }

                    // Load each book
                    keys.forEach(key => {
                        const result = this.storage.load(key);
                        if (result.success && result.data) {
                            const book = new Book(result.data);
                            this.books.set(book.id, book);
                        }
                    });

                    if (this.books.size > 0) {
                        log(`üìö Loaded ${this.books.size} book(s) from storage`, 'info');
                    }
                } catch (error) {
                    log(`‚ö†Ô∏è Error loading books: ${error.message}`, 'warning');
                }
            }

            updateDisplay() {
                this.updateStats();
                this.displayBooks();
            }

            updateStats() {
                const books = this.getAllBooks();
                const totalBooks = books.length;
                const totalWords = books.reduce((sum, book) => sum + book.wordCount, 0);
                const avgProgress = totalBooks > 0 
                    ? Math.round(books.reduce((sum, book) => sum + book.progress, 0) / totalBooks * 100)
                    : 0;

                document.getElementById('total-books').textContent = totalBooks;
                document.getElementById('total-words').textContent = totalWords.toLocaleString();
                document.getElementById('avg-progress').textContent = `${avgProgress}%`;
            }

            displayBooks() {
                const container = document.getElementById('books-container');
                const emptyLibrary = document.getElementById('empty-library');
                
                // Get filtered and sorted books
                let books = this.searchBooks(this.searchQuery);
                books = this.sortBooks(books, this.sortBy);

                // Show/hide empty state
                if (books.length === 0) {
                    container.innerHTML = '';
                    container.appendChild(emptyLibrary);
                    return;
                }

                // Remove empty state
                if (container.contains(emptyLibrary)) {
                    container.removeChild(emptyLibrary);
                }

                // Clear and populate with books
                container.innerHTML = '';
                books.forEach(book => {
                    const bookElement = this.createBookElement(book);
                    container.appendChild(bookElement);
                });
            }

            createBookElement(book) {
                const bookCard = document.createElement('div');
                bookCard.className = 'book-card';
                
                const progressPercent = Math.round(book.progress * 100);
                const readingTime = book.getReadingTime();
                const timeToFinish = book.getTimeToFinish();
                const uploadDate = new Date(book.uploadDate).toLocaleDateString();
                const lastReadText = book.lastRead 
                    ? `Last read: ${new Date(book.lastRead).toLocaleDateString()}`
                    : 'Never read';

                bookCard.innerHTML = `
                    <div class="book-header">
                        <div>
                            <div class="book-title">${book.title}</div>
                            <div class="book-meta">
                                <span class="meta-item">üìä ${book.wordCount.toLocaleString()} words</span>
                                <span class="meta-item">‚è±Ô∏è ${readingTime} min read</span>
                                <span class="meta-item">üìÖ ${uploadDate}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="book-preview">"${book.preview}"</div>
                    
                    <div class="book-meta">
                        <span class="meta-item">üìñ ${progressPercent}% completed</span>
                        <span class="meta-item">‚è∞ ${timeToFinish} min left</span>
                        <span class="meta-item">${lastReadText}</span>
                    </div>
                    
                    <div class="book-progress">
                        <div class="progress-bar-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    
                    <div class="book-actions">
                        <button onclick="bookManager.openBook('${book.id}')" class="btn btn-primary">üìñ Read</button>
                        <button onclick="bookManager.showBookInfo('${book.id}')" class="btn btn-secondary">‚ÑπÔ∏è Info</button>
                        <button onclick="bookManager.updateProgress('${book.id}')" class="btn btn-success">‚úÖ Progress</button>
                        <button onclick="bookManager.confirmRemoveBook('${book.id}')" class="btn btn-danger">üóëÔ∏è Remove</button>
                    </div>
                `;

                return bookCard;
            }

            openBook(bookId) {
                const book = this.getBook(bookId);
                if (!book) {
                    log(`‚ùå Book not found: ${bookId}`, 'error');
                    return;
                }

                log(`üìñ Opening book: ${book.title}`, 'info');
                log(`Content preview: "${book.content.substring(0, 500)}..."`, 'info');
                updateStatus(`üìñ Reading: ${book.title} (${book.wordCount} words, ${Math.round(book.progress * 100)}% complete)`);
                
                // Simulate reading progress update
                const newProgress = Math.min(1, book.progress + 0.1);
                this.updateBookProgress(bookId, newProgress);
            }

            showBookInfo(bookId) {
                const book = this.getBook(bookId);
                if (!book) {
                    log(`‚ùå Book not found: ${bookId}`, 'error');
                    return;
                }

                log(`üìã Book Information for: ${book.title}`, 'info');
                log(`üìÑ Filename: ${book.filename}`, 'info');
                log(`üìä Word Count: ${book.wordCount.toLocaleString()} words`, 'info');
                log(`üìè File Size: ${Math.round(book.size / 1024)} KB`, 'info');
                log(`üìÖ Upload Date: ${new Date(book.uploadDate).toLocaleString()}`, 'info');
                log(`üìñ Reading Progress: ${Math.round(book.progress * 100)}%`, 'info');
                log(`‚≠ê Rating: ${book.rating}/5 stars`, 'info');
                log(`üè∑Ô∏è Tags: ${book.tags.length > 0 ? book.tags.join(', ') : 'None'}`, 'info');
                log(`üìù Notes: ${book.notes.length} note(s)`, 'info');
                log(`üîñ Bookmarks: ${book.bookmarks.length} bookmark(s)`, 'info');
                
                updateStatus(`üìã Showing info for: ${book.title}`);
            }

            updateProgress(bookId) {
                const book = this.getBook(bookId);
                if (!book) {
                    log(`‚ùå Book not found: ${bookId}`, 'error');
                    return;
                }

                const currentPercent = Math.round(book.progress * 100);
                const newPercent = prompt(`Update reading progress for "${book.title}"\nCurrent progress: ${currentPercent}%\nEnter new progress (0-100):`);
                
                if (newPercent === null) return; // User cancelled
                
                const progress = parseInt(newPercent);
                if (isNaN(progress) || progress < 0 || progress > 100) {
                    log(`‚ùå Invalid progress value: ${newPercent}`, 'error');
                    return;
                }

                const result = this.updateBookProgress(bookId, progress / 100);
                if (result.success) {
                    log(`‚úÖ Updated progress for "${book.title}" to ${progress}%`, 'success');
                    updateStatus(`‚úÖ Progress updated: ${book.title} is now ${progress}% complete`);
                } else {
                    log(`‚ùå Failed to update progress: ${result.message}`, 'error');
                }
            }

            confirmRemoveBook(bookId) {
                const book = this.getBook(bookId);
                if (!book) {
                    log(`‚ùå Book not found: ${bookId}`, 'error');
                    return;
                }

                if (confirm(`Are you sure you want to remove "${book.title}" from your library?\n\nThis action cannot be undone.`)) {
                    const result = this.removeBook(bookId);
                    if (result.success) {
                        updateStatus(`üóëÔ∏è Removed: ${book.title}`);
                    } else {
                        log(`‚ùå Failed to remove book: ${result.message}`, 'error');
                    }
                }
            }

            getLibraryStats() {
                const books = this.getAllBooks();
                const totalBooks = books.length;
                const totalWords = books.reduce((sum, book) => sum + book.wordCount, 0);
                const totalSize = books.reduce((sum, book) => sum + book.size, 0);
                const avgProgress = totalBooks > 0 
                    ? books.reduce((sum, book) => sum + book.progress, 0) / totalBooks
                    : 0;
                const booksRead = books.filter(book => book.progress >= 1).length;
                const booksInProgress = books.filter(book => book.progress > 0 && book.progress < 1).length;
                const booksUnread = books.filter(book => book.progress === 0).length;

                return {
                    totalBooks,
                    totalWords,
                    totalSize,
                    avgProgress,
                    booksRead,
                    booksInProgress,
                    booksUnread,
                    averageWordCount: totalBooks > 0 ? Math.round(totalWords / totalBooks) : 0,
                    averageSize: totalBooks > 0 ? Math.round(totalSize / totalBooks) : 0
                };
            }

            exportLibrary() {
                const books = this.getAllBooks().map(book => book.toJSON());
                const exportData = {
                    exportDate: new Date().toISOString(),
                    version: '1.0',
                    books: books,
                    stats: this.getLibraryStats()
                };

                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `book-buddy-library-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                log(`üì§ Library exported: ${books.length} books`, 'success');
            }
        }

        // === COMPONENT 3: FileUploadHandler (Updated to work with BookManager) ===
        class FileUploadHandler {
            constructor(storageManager, bookManager) {
                this.storage = storageManager;
                this.bookManager = bookManager;
                this.maxFileSize = 2 * 1024 * 1024;
                this.allowedTypes = ['.txt'];
                this.allowedMimeTypes = ['text/plain'];
                
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                const uploadSection = document.getElementById('upload-section');
                const fileInput = document.getElementById('file-input');

                fileInput.addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });

                uploadSection.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadSection.classList.add('drag-over');
                });

                uploadSection.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    uploadSection.classList.remove('drag-over');
                });

                uploadSection.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadSection.classList.remove('drag-over');
                    this.handleFiles(e.dataTransfer.files);
                });
            }

            async handleFiles(files) {
                if (!files || files.length === 0) return;

                log(`üìÇ Processing ${files.length} file(s)...`, 'info');

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    await this.processFile(file);
                }

                updateStatus(`Successfully processed ${files.length} file(s)!`);
            }

            async processFile(file) {
                try {
                    this.showProgress(file.name);

                    const validation = this.validateFile(file);
                    if (!validation.valid) {
                        log(`‚ùå ${file.name}: ${validation.error}`, 'error');
                        this.hideProgress();
                        return;
                    }

                    this.updateProgress(25, 'Validating...');

                    const content = await this.readFileContent(file);
                    this.updateProgress(75, 'Processing...');

                    const bookData = this.createBookData(file, content);
                    
                    // Use BookManager to add the book
                    const result = this.bookManager.addBook(bookData);
                    if (!result.success) {
                        log(`‚ùå Failed to add ${file.name}: ${result.message}`, 'error');
                        this.hideProgress();
                        return;
                    }

                    this.updateProgress(100, 'Complete!');
                    log(`‚úÖ Successfully uploaded: ${file.name}`, 'success');

                    setTimeout(() => this.hideProgress(), 1000);
                } catch (error) {
                    log(`‚ùå Error processing ${file.name}: ${error.message}`, 'error');
                    this.hideProgress();
                }
            }

            validateFile(file) {
                const fileName = file.name.toLowerCase();
                const hasValidExtension = this.allowedTypes.some(type => fileName.endsWith(type));
                
                if (!hasValidExtension) {
                    return {
                        valid: false,
                        error: `Invalid file type. Only ${this.allowedTypes.join(', ')} files are allowed.`
                    };
                }

                if (!this.allowedMimeTypes.includes(file.type) && file.type !== '') {
                    return {
                        valid: false,
                        error: 'Invalid file format. Please upload a text file.'
                    };
                }

                if (file.size > this.maxFileSize) {
                    const maxSizeMB = this.maxFileSize / (1024 * 1024);
                    return {
                        valid: false,
                        error: `File too large. Maximum size is ${maxSizeMB}MB.`
                    };
                }

                if (file.size === 0) {
                    return {
                        valid: false,
                        error: 'File is empty.'
                    };
                }

                return { valid: true };
            }

            readFileContent(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        resolve(e.target.result);
                    };
                    
                    reader.onerror = () => {
                        reject(new Error('Failed to read file'));
                    };
                    
                    reader.readAsText(file);
                });
            }

            createBookData(file, content) {
                return {
                    title: this.extractTitle(file.name),
                    filename: file.name,
                    content: content,
                    size: file.size,
                    lastModified: new Date(file.lastModified).toISOString()
                };
            }

            extractTitle(filename) {
                return filename
                    .replace(/\.[^/.]+$/, '')
                    .replace(/[_-]/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase());
            }

            showProgress(filename) {
                const progressContainer = document.getElementById('progress-container');
                const currentFile = document.getElementById('current-file');
                
                currentFile.textContent = filename;
                progressContainer.style.display = 'block';
                this.updateProgress(0, 'Starting...');
            }

            updateProgress(percent, status) {
                const progressFill = document.getElementById('progress-fill');
                const progressText = document.getElementById('progress-text');
                
                progressFill.style.width = `${percent}%`;
                progressText.textContent = `${percent}% - ${status}`;
            }

            hideProgress() {
                const progressContainer = document.getElementById('progress-container');
                progressContainer.style.display = 'none';
            }
        }

        // === APP INITIALIZATION ===
        let consoleOutput = '';
        const storage = new StorageManager('book-buddy');
        const bookManager = new BookManager(storage);
        const fileUploader = new FileUploadHandler(storage, bookManager);

        // === UTILITY FUNCTIONS ===
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            const output = `[${timestamp}] ${prefix} ${message}\n`;
            consoleOutput += output;
            
            const outputDiv = document.getElementById('console-output');
            outputDiv.textContent = consoleOutput;
            outputDiv.style.display = 'block';
            outputDiv.scrollTop = outputDiv.scrollHeight;
            
            console.log(message);
        }

        function updateStatus(message) {
            document.getElementById('status-message').textContent = message;
        }

        // === TEST FUNCTIONS ===
        function testBookManager() {
            consoleOutput = '';
            log('üìö Testing BookManager Component...', 'info');
            updateStatus('Testing library manager functionality...');

            // Test Book class
            log('üìñ Testing Book class...', 'info');
            const testBookData = {
                title: 'Test Book',
                content: 'This is a test book with some content for testing purposes.',
                filename: 'test-book.txt',
                size: 1024
            };

            const book = new Book(testBookData);
            log(`Book creation: ${book.title === 'Test Book' ? 'PASS' : 'FAIL'}`, 
                book.title === 'Test Book' ? 'success' : 'error');
            log(`Word count calculation: ${book.wordCount === 12 ? 'PASS' : 'FAIL'} - Got: ${book.wordCount}`, 
                book.wordCount === 12 ? 'success' : 'error');

            // Test progress update
            book.updateProgress(0.5);
            log(`Progress update: ${book.progress === 0.5 ? 'PASS' : 'FAIL'}`, 
                book.progress === 0.5 ? 'success' : 'error');

            // Test BookManager functionality
            log('üìö Testing BookManager functionality...', 'info');
            const initialCount = bookManager.getAllBooks().length;
            
            const addResult = bookManager.addBook(testBookData);
            log(`Add book: ${addResult.success ? 'PASS' : 'FAIL'} - ${addResult.success ? 'Book added' : addResult.message}`, 
                addResult.success ? 'success' : 'error');

            const newCount = bookManager.getAllBooks().length;
            log(`Book count increased: ${newCount === initialCount + 1 ? 'PASS' : 'FAIL'}`, 
                newCount === initialCount + 1 ? 'success' : 'error');

            // Test search
            const searchResults = bookManager.searchBooks('test');
            log(`Search functionality: ${searchResults.length > 0 ? 'PASS' : 'FAIL'}`, 
                searchResults.length > 0 ? 'success' : 'error');

            // Test stats
            const stats = bookManager.getLibraryStats();
            log(`Library stats: Total books: ${stats.totalBooks}, Total words: ${stats.totalWords}`, 'info');

            log('‚úÖ BookManager component tests completed!', 'success');
            updateStatus('BookManager tests completed! Library functionality is ready.');
        }

        function addSampleBooks() {
            log('üìö Adding sample books to library...', 'info');
            
            const sampleBooks = [
                {
                    title: 'The Great Gatsby',
                    content: 'In my younger and more vulnerable years my father gave me some advice that I\'ve carried with me ever since. "Whenever you feel like criticizing anyone," he told me, "just remember that all the people in this world haven\'t had the advantages that you\'ve had." This classic American novel explores themes of wealth, love, and the American Dream through the eyes of Nick Carraway.',
                    filename: 'great-gatsby.txt',
                    size: 2048
                },
                {
                    title: '1984',
                    content: 'It was a bright cold day in April, and the clocks were striking thirteen. Winston Smith, his chin nuzzled into his breast in an effort to escape the vile wind, slipped quickly through the glass doors of Victory Mansions. This dystopian novel presents a terrifying vision of totalitarian control and the struggle for individual freedom.',
                    filename: '1984.txt',
                    size: 3072
                },
                {
                    title: 'Pride and Prejudice',
                    content: 'It is a truth universally acknowledged, that a single man in possession of a good fortune, must be in want of a wife. This witty social commentary follows Elizabeth Bennet as she navigates the complex world of marriage, family, and social expectations in Regency England.',
                    filename: 'pride-prejudice.txt',
                    size: 2560
                }
            ];

            sampleBooks.forEach(bookData => {
                const result = bookManager.addBook(bookData);
                if (result.success) {
                    log(`‚úÖ Added sample book: ${bookData.title}`, 'success');
                    
                    // Add some sample progress
                    const randomProgress = Math.random() * 0.8; // 0-80% progress
                    bookManager.updateBookProgress(result.book.id, randomProgress);
                } else {
                    log(`‚ùå Failed to add ${bookData.title}: ${result.message}`, 'error');
                }
            });

            updateStatus(`üìö Added ${sampleBooks.length} sample books to your library!`);
        }

        function testFileUpload() {
            consoleOutput = '';
            log('üìÇ Testing File Upload Component...', 'info');
            updateStatus('Testing file upload functionality...');

            const validFile = new File(['This is a test book content with multiple words to test the upload functionality.'], 'test-upload.txt', {
                type: 'text/plain',
                lastModified: Date.now()
            });

            const invalidFile = new File(['test'], 'test.pdf', {
                type: 'application/pdf',
                lastModified: Date.now()
            });

            const validResult = fileUploader.validateFile(validFile);
            log(`Valid .txt file: ${validResult.valid ? 'PASS' : 'FAIL'} - ${validResult.error || 'OK'}`, 
                validResult.valid ? 'success' : 'error');

            const invalidResult = fileUploader.validateFile(invalidFile);
            log(`Invalid .pdf file: ${!invalidResult.valid ? 'PASS' : 'FAIL'} - ${invalidResult.error || 'Should fail'}`, 
                !invalidResult.valid ? 'success' : 'error');

            const testTitle = fileUploader.extractTitle('the-great-gatsby.txt');
            log(`Title extraction: ${testTitle === 'The Great Gatsby' ? 'PASS' : 'FAIL'} - Got: "${testTitle}"`, 
                testTitle === 'The Great Gatsby' ? 'success' : 'error');

            log('‚úÖ File upload component tests completed!', 'success');
            updateStatus('File upload tests completed! Try uploading a real .txt file above.');
        }

        function runAllTests() {
            consoleOutput = '';
            log('üß™ Starting All Components Tests...', 'info');
            updateStatus('Running comprehensive tests...');
            
            testBasicOperations();
            testComplexData();
            testErrorHandling();
            testStorageManagement();
            testFileUpload();
            testBookManager();
            
            log('‚úÖ All component tests completed!', 'success');
            updateStatus('All tests completed! Book Buddy is fully functional.');
        }

        function testBasicOperations() {
            log('üìù Testing basic storage operations...', 'info');
            
            let result = storage.save('test_string', 'Hello World');
            log(`Save string: ${result.success ? 'PASS' : 'FAIL'} - ${result.message}`, 
                result.success ? 'success' : 'error');
            
            result = storage.load('test_string');
            log(`Load string: ${result.success && result.data === 'Hello World' ? 'PASS' : 'FAIL'} - Got: ${result.data}`, 
                result.success && result.data === 'Hello World' ? 'success' : 'error');
        }

        function testComplexData() {
            log('üìä Testing complex data structures...', 'info');
            
            const complexData = {
                id: 'test_1',
                nested: { value: 42 },
                array: [1, 2, 3]
            };
            
            let result = storage.save('complex_test', complexData);
            log(`Save complex object: ${result.success ? 'PASS' : 'FAIL'}`, 
                result.success ? 'success' : 'error');
            
            result = storage.load('complex_test');
            const isValid = result.success && result.data.nested.value === 42;
            log(`Load complex object: ${isValid ? 'PASS' : 'FAIL'}`, 
                isValid ? 'success' : 'error');
        }

        function testErrorHandling() {
            log('üö´ Testing error handling...', 'info');
            
            localStorage.setItem('book-buddy_corrupted', '{invalid json');
            const result = storage.load('corrupted', 'fallback');
            log(`Corrupted data handling: ${result.data === 'fallback' ? 'PASS' : 'FAIL'}`, 
                result.data === 'fallback' ? 'success' : 'error');
        }

        function testStorageManagement() {
            log('üóÇÔ∏è Testing storage management...', 'info');
            
            const info = storage.getStorageInfo();
            log(`Storage info available: ${info.available ? 'PASS' : 'FAIL'}`, 
                info.available ? 'success' : 'error');
            
            if (info.available) {
                log(`Storage usage: ${info.appSize} bytes (${info.appPercentUsed}%)`, 'info');
            }
        }

        function demonstrateUsage() {
            consoleOutput = '';
            log('üìñ Book Buddy Complete Usage Examples', 'info');
            updateStatus('Running complete usage demonstration...');
            
            log('üìö Library Management Features:', 'info');
            log(`- Current library size: ${bookManager.getAllBooks().length} books`, 'info');
            
            const stats = bookManager.getLibraryStats();
            log(`- Total words in library: ${stats.totalWords.toLocaleString()}`, 'info');
            log(`- Average reading progress: ${Math.round(stats.avgProgress * 100)}%`, 'info');
            log(`- Books completed: ${stats.booksRead}`, 'info');
            log(`- Books in progress: ${stats.booksInProgress}`, 'info');
            log(`- Unread books: ${stats.booksUnread}`, 'info');
            
            log('üîç Search and Filter Features:', 'info');
            log(`- Search by title or content`, 'info');
            log(`- Sort by title, date, size, or progress`, 'info');
            log(`- Grid and list view modes`, 'info');
            
            log('üìñ Book Management Features:', 'info');
            log(`- Reading progress tracking`, 'info');
            log(`- Bookmark and note support`, 'info');
            log(`- Tag organization`, 'info');
            log(`- Reading time estimation`, 'info');
            
            updateStatus('Usage demonstration completed! Your library is ready to use.');
        }

        function cleanupTestData() {
            log('üßπ Cleaning up all test data...', 'info');
            
            const result = storage.clear();
            bookManager.books.clear();
            bookManager.updateDisplay();
            
            log(`Cleanup result: ${result.success ? 'SUCCESS' : 'FAILED'} - ${result.message}`, 
                result.success ? 'success' : 'error');
            updateStatus('All test data cleaned up! Library reset to empty state.');
        }

        // === APP STARTUP ===
        updateStatus('üìö Book Buddy Library Manager ready! Upload files or add sample books to get started.');
        log('üöÄ Book Buddy with Library Manager initialized!', 'success');
        log(`Storage available: ${storage.isAvailable}`, 'info');
        log(`Components loaded: StorageManager, Book, BookManager, FileUploadHandler`, 'info');
        
        const initialTest = storage.save('app_initialized', { 
            timestamp: new Date().toISOString(),
            version: '1.2.0',
            components: ['StorageManager', 'Book', 'BookManager', 'FileUploadHandler']
        });
        
        if (initialTest.success) {
            log('‚úÖ All components initialized successfully!', 'success');
        } else {
            log('‚ùå Component initialization failed!', 'error');
        }

        // Make bookManager available globally for button clicks
        window.bookManager = bookManager;
        window.fileUploader = fileUploader;
    </script>
</body>
</html>